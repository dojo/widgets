{"version":3,"file":"Drag.js","sourceRoot":"","sources":["../../../../../src/widget-core/meta/Drag.ts"],"names":[],"mappings":"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","sourcesContent":["import { deepAssign } from '../../core/lang';\nimport global from '../../shim/global';\nimport { assign } from '../../shim/object';\nimport WeakMap from '../../shim/WeakMap';\nimport { Base } from './Base';\n\nexport interface DragResults {\n\t/**\n\t * The movement of pointer during the duration of the drag state\n\t */\n\tdelta: Position;\n\n\t/**\n\t * Is the DOM node currently in a drag state\n\t */\n\tisDragging: boolean;\n\n\t/**\n\t * A matrix of posistions that represent the start position for the current drag interaction\n\t */\n\tstart?: PositionMatrix;\n}\n\ninterface NodeData {\n\tdragResults: DragResults;\n\tinvalidate: () => void;\n\tlast: PositionMatrix;\n\tstart: PositionMatrix;\n}\n\n/**\n * An x/y position structure\n */\nexport interface Position {\n\tx: number;\n\ty: number;\n}\n\n/**\n * A matrix of x/y positions\n */\nexport interface PositionMatrix {\n\t/**\n\t * Client x/y position\n\t */\n\tclient: Position;\n\n\t/**\n\t * Offset x/y position\n\t */\n\toffset: Position;\n\n\t/**\n\t * Page x/y position\n\t */\n\tpage: Position;\n\n\t/**\n\t * Screen x/y position\n\t */\n\tscreen: Position;\n}\n\nfunction createNodeData(invalidate: () => void): NodeData {\n\treturn {\n\t\tdragResults: deepAssign({}, emptyResults),\n\t\tinvalidate,\n\t\tlast: createPositionMatrix(),\n\t\tstart: createPositionMatrix()\n\t};\n}\n\n/**\n * Creates an empty position\n */\nfunction createPosition(): Position {\n\treturn { x: 0, y: 0 };\n}\n\n/**\n * Create an empty position matrix\n */\nfunction createPositionMatrix(): PositionMatrix {\n\treturn {\n\t\tclient: { x: 0, y: 0 },\n\t\toffset: { x: 0, y: 0 },\n\t\tpage: { x: 0, y: 0 },\n\t\tscreen: { x: 0, y: 0 }\n\t};\n}\n\n/**\n * A frozen empty result object, frozen to ensure that no one downstream modifies it\n */\nconst emptyResults = Object.freeze({\n\tdelta: Object.freeze(createPosition()),\n\tisDragging: false\n});\n\n/**\n * Return the x/y position matrix for an event\n * @param event The pointer event\n */\nfunction getPositionMatrix(event: PointerEvent): PositionMatrix {\n\treturn {\n\t\tclient: {\n\t\t\tx: event.clientX,\n\t\t\ty: event.clientY\n\t\t},\n\t\toffset: {\n\t\t\tx: event.offsetX,\n\t\t\ty: event.offsetY\n\t\t},\n\t\tpage: {\n\t\t\tx: event.pageX,\n\t\t\ty: event.pageY\n\t\t},\n\t\tscreen: {\n\t\t\tx: event.screenX,\n\t\t\ty: event.screenY\n\t\t}\n\t};\n}\n\n/**\n * Return the delta position between two positions\n * @param start The first position\n * @param current The second position\n */\nfunction getDelta(start: PositionMatrix, current: PositionMatrix): Position {\n\treturn {\n\t\tx: current.client.x - start.client.x,\n\t\ty: current.client.y - start.client.y\n\t};\n}\n\n/**\n * Sets the `touch-action` on nodes so that PointerEvents are always emitted for the node\n * @param node The node to init\n */\nfunction initNode(node: HTMLElement): void {\n\t// Ensure that the node has `touch-action` none\n\tnode.style.touchAction = 'none';\n\t// PEP requires an attribute of `touch-action` to be set on the element\n\tnode.setAttribute('touch-action', 'none');\n}\n\nclass DragController {\n\tprivate _nodeMap = new WeakMap<HTMLElement, NodeData>();\n\tprivate _dragging: HTMLElement | undefined = undefined;\n\n\tprivate _getData(target: HTMLElement): { state: NodeData; target: HTMLElement } | undefined {\n\t\tif (this._nodeMap.has(target)) {\n\t\t\treturn { state: this._nodeMap.get(target)!, target };\n\t\t}\n\t\tif (target.parentElement) {\n\t\t\treturn this._getData(target.parentElement);\n\t\t}\n\t}\n\n\tprivate _onDragStart = (event: PointerEvent) => {\n\t\tconst { _dragging } = this;\n\t\tif (!event.isPrimary && _dragging) {\n\t\t\t// we have a second touch going on here, while we are dragging, so we aren't really dragging, so we\n\t\t\t// will close this down\n\t\t\tconst state = this._nodeMap.get(_dragging)!;\n\t\t\tstate.dragResults.isDragging = false;\n\t\t\tstate.invalidate();\n\t\t\tthis._dragging = undefined;\n\t\t\treturn;\n\t\t}\n\t\tif (event.button !== 0) {\n\t\t\t// it isn't the primary button that is being clicked, so we will ignore this\n\t\t\treturn;\n\t\t}\n\t\tconst data = this._getData(event.target as HTMLElement);\n\t\tif (data) {\n\t\t\tconst { state, target } = data;\n\t\t\tthis._dragging = target;\n\t\t\tstate.last = state.start = getPositionMatrix(event);\n\t\t\tstate.dragResults.delta = createPosition();\n\t\t\tstate.dragResults.start = deepAssign({}, state.start);\n\t\t\tstate.dragResults.isDragging = true;\n\t\t\tstate.invalidate();\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t} // else, we are ignoring the event\n\t};\n\n\tprivate _onDrag = (event: PointerEvent) => {\n\t\tconst { _dragging } = this;\n\t\tif (!_dragging) {\n\t\t\treturn;\n\t\t}\n\t\t// state cannot be unset, using ! operator\n\t\tconst state = this._nodeMap.get(_dragging)!;\n\t\tstate.last = getPositionMatrix(event);\n\t\tstate.dragResults.delta = getDelta(state.start, state.last);\n\t\tif (!state.dragResults.start) {\n\t\t\tstate.dragResults.start = deepAssign({}, state.start);\n\t\t}\n\t\tstate.invalidate();\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t};\n\n\tprivate _onDragStop = (event: PointerEvent) => {\n\t\tconst { _dragging } = this;\n\t\tif (!_dragging) {\n\t\t\treturn;\n\t\t}\n\t\t// state cannot be unset, using ! operator\n\t\tconst state = this._nodeMap.get(_dragging)!;\n\t\tstate.last = getPositionMatrix(event);\n\t\tstate.dragResults.delta = getDelta(state.start, state.last);\n\t\tif (!state.dragResults.start) {\n\t\t\tstate.dragResults.start = deepAssign({}, state.start);\n\t\t}\n\t\tstate.dragResults.isDragging = false;\n\t\tstate.invalidate();\n\t\tthis._dragging = undefined;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t};\n\n\tconstructor() {\n\t\tconst win: Window = global.window;\n\t\twin.addEventListener('pointerdown', this._onDragStart);\n\t\t// Use capture phase, to determine the right node target, as it will be top down versus bottom up\n\t\twin.addEventListener('pointermove', this._onDrag, true);\n\t\twin.addEventListener('pointerup', this._onDragStop, true);\n\t}\n\n\tpublic get(node: HTMLElement, invalidate: () => void): DragResults {\n\t\tconst { _nodeMap } = this;\n\t\t// first time we see a node, we will initialize its state and properties\n\t\tif (!_nodeMap.has(node)) {\n\t\t\t_nodeMap.set(node, createNodeData(invalidate));\n\t\t\tinitNode(node);\n\t\t\treturn emptyResults;\n\t\t}\n\n\t\tconst state = _nodeMap.get(node)!;\n\t\t// shallow \"clone\" the results, so no downstream manipulation can occur\n\t\tconst dragResults = assign({}, state.dragResults);\n\t\t// we are offering up an accurate delta, so we need to take the last event position and move it to the start so\n\t\t// that our deltas are calculated from the last time they are read\n\t\tstate.start = state.last;\n\t\t// reset the delta after we have read, as any future reads should have an empty delta\n\t\tstate.dragResults.delta = createPosition();\n\t\t// clear the start state\n\t\tdelete state.dragResults.start;\n\n\t\treturn dragResults;\n\t}\n}\n\nconst controller = new DragController();\n\nexport class Drag extends Base {\n\tprivate _boundInvalidate: () => void = this.invalidate.bind(this);\n\n\tpublic get(key: string | number): Readonly<DragResults> {\n\t\tconst node = this.getNode(key) as HTMLElement;\n\n\t\t// if we don't have a reference to the node yet, return an empty set of results\n\t\tif (!node) {\n\t\t\treturn emptyResults;\n\t\t}\n\n\t\t// otherwise we will ask the controller for our results\n\t\treturn controller.get(node, this._boundInvalidate);\n\t}\n}\n\nexport default Drag;\n"]}