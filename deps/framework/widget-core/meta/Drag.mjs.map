{"version":3,"file":"Drag.mjs","sourceRoot":"","sources":["../../../../../src/widget-core/meta/Drag.ts"],"names":[],"mappings":"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","sourcesContent":["import { deepAssign } from '../../core/lang';\nimport global from '../../shim/global';\nimport { assign } from '../../shim/object';\nimport WeakMap from '../../shim/WeakMap';\nimport { Base } from './Base';\n\nexport interface DragResults {\n\t/**\n\t * The movement of pointer during the duration of the drag state\n\t */\n\tdelta: Position;\n\n\t/**\n\t * Is the DOM node currently in a drag state\n\t */\n\tisDragging: boolean;\n\n\t/**\n\t * A matrix of posistions that represent the start position for the current drag interaction\n\t */\n\tstart?: PositionMatrix;\n}\n\ninterface NodeData {\n\tdragResults: DragResults;\n\tinvalidate: () => void;\n\tlast: PositionMatrix;\n\tstart: PositionMatrix;\n}\n\n/**\n * An x/y position structure\n */\nexport interface Position {\n\tx: number;\n\ty: number;\n}\n\n/**\n * A matrix of x/y positions\n */\nexport interface PositionMatrix {\n\t/**\n\t * Client x/y position\n\t */\n\tclient: Position;\n\n\t/**\n\t * Offset x/y position\n\t */\n\toffset: Position;\n\n\t/**\n\t * Page x/y position\n\t */\n\tpage: Position;\n\n\t/**\n\t * Screen x/y position\n\t */\n\tscreen: Position;\n}\n\nfunction createNodeData(invalidate: () => void): NodeData {\n\treturn {\n\t\tdragResults: deepAssign({}, emptyResults),\n\t\tinvalidate,\n\t\tlast: createPositionMatrix(),\n\t\tstart: createPositionMatrix()\n\t};\n}\n\n/**\n * Creates an empty position\n */\nfunction createPosition(): Position {\n\treturn { x: 0, y: 0 };\n}\n\n/**\n * Create an empty position matrix\n */\nfunction createPositionMatrix(): PositionMatrix {\n\treturn {\n\t\tclient: { x: 0, y: 0 },\n\t\toffset: { x: 0, y: 0 },\n\t\tpage: { x: 0, y: 0 },\n\t\tscreen: { x: 0, y: 0 }\n\t};\n}\n\n/**\n * A frozen empty result object, frozen to ensure that no one downstream modifies it\n */\nconst emptyResults = Object.freeze({\n\tdelta: Object.freeze(createPosition()),\n\tisDragging: false\n});\n\n/**\n * Return the x/y position matrix for an event\n * @param event The pointer event\n */\nfunction getPositionMatrix(event: PointerEvent): PositionMatrix {\n\treturn {\n\t\tclient: {\n\t\t\tx: event.clientX,\n\t\t\ty: event.clientY\n\t\t},\n\t\toffset: {\n\t\t\tx: event.offsetX,\n\t\t\ty: event.offsetY\n\t\t},\n\t\tpage: {\n\t\t\tx: event.pageX,\n\t\t\ty: event.pageY\n\t\t},\n\t\tscreen: {\n\t\t\tx: event.screenX,\n\t\t\ty: event.screenY\n\t\t}\n\t};\n}\n\n/**\n * Return the delta position between two positions\n * @param start The first position\n * @param current The second position\n */\nfunction getDelta(start: PositionMatrix, current: PositionMatrix): Position {\n\treturn {\n\t\tx: current.client.x - start.client.x,\n\t\ty: current.client.y - start.client.y\n\t};\n}\n\n/**\n * Sets the `touch-action` on nodes so that PointerEvents are always emitted for the node\n * @param node The node to init\n */\nfunction initNode(node: HTMLElement): void {\n\t// Ensure that the node has `touch-action` none\n\tnode.style.touchAction = 'none';\n\t// PEP requires an attribute of `touch-action` to be set on the element\n\tnode.setAttribute('touch-action', 'none');\n}\n\nclass DragController {\n\tprivate _nodeMap = new WeakMap<HTMLElement, NodeData>();\n\tprivate _dragging: HTMLElement | undefined = undefined;\n\n\tprivate _getData(target: HTMLElement): { state: NodeData; target: HTMLElement } | undefined {\n\t\tif (this._nodeMap.has(target)) {\n\t\t\treturn { state: this._nodeMap.get(target)!, target };\n\t\t}\n\t\tif (target.parentElement) {\n\t\t\treturn this._getData(target.parentElement);\n\t\t}\n\t}\n\n\tprivate _onDragStart = (event: PointerEvent) => {\n\t\tconst { _dragging } = this;\n\t\tif (!event.isPrimary && _dragging) {\n\t\t\t// we have a second touch going on here, while we are dragging, so we aren't really dragging, so we\n\t\t\t// will close this down\n\t\t\tconst state = this._nodeMap.get(_dragging)!;\n\t\t\tstate.dragResults.isDragging = false;\n\t\t\tstate.invalidate();\n\t\t\tthis._dragging = undefined;\n\t\t\treturn;\n\t\t}\n\t\tif (event.button !== 0) {\n\t\t\t// it isn't the primary button that is being clicked, so we will ignore this\n\t\t\treturn;\n\t\t}\n\t\tconst data = this._getData(event.target as HTMLElement);\n\t\tif (data) {\n\t\t\tconst { state, target } = data;\n\t\t\tthis._dragging = target;\n\t\t\tstate.last = state.start = getPositionMatrix(event);\n\t\t\tstate.dragResults.delta = createPosition();\n\t\t\tstate.dragResults.start = deepAssign({}, state.start);\n\t\t\tstate.dragResults.isDragging = true;\n\t\t\tstate.invalidate();\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t} // else, we are ignoring the event\n\t};\n\n\tprivate _onDrag = (event: PointerEvent) => {\n\t\tconst { _dragging } = this;\n\t\tif (!_dragging) {\n\t\t\treturn;\n\t\t}\n\t\t// state cannot be unset, using ! operator\n\t\tconst state = this._nodeMap.get(_dragging)!;\n\t\tstate.last = getPositionMatrix(event);\n\t\tstate.dragResults.delta = getDelta(state.start, state.last);\n\t\tif (!state.dragResults.start) {\n\t\t\tstate.dragResults.start = deepAssign({}, state.start);\n\t\t}\n\t\tstate.invalidate();\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t};\n\n\tprivate _onDragStop = (event: PointerEvent) => {\n\t\tconst { _dragging } = this;\n\t\tif (!_dragging) {\n\t\t\treturn;\n\t\t}\n\t\t// state cannot be unset, using ! operator\n\t\tconst state = this._nodeMap.get(_dragging)!;\n\t\tstate.last = getPositionMatrix(event);\n\t\tstate.dragResults.delta = getDelta(state.start, state.last);\n\t\tif (!state.dragResults.start) {\n\t\t\tstate.dragResults.start = deepAssign({}, state.start);\n\t\t}\n\t\tstate.dragResults.isDragging = false;\n\t\tstate.invalidate();\n\t\tthis._dragging = undefined;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t};\n\n\tconstructor() {\n\t\tconst win: Window = global.window;\n\t\twin.addEventListener('pointerdown', this._onDragStart);\n\t\t// Use capture phase, to determine the right node target, as it will be top down versus bottom up\n\t\twin.addEventListener('pointermove', this._onDrag, true);\n\t\twin.addEventListener('pointerup', this._onDragStop, true);\n\t}\n\n\tpublic get(node: HTMLElement, invalidate: () => void): DragResults {\n\t\tconst { _nodeMap } = this;\n\t\t// first time we see a node, we will initialize its state and properties\n\t\tif (!_nodeMap.has(node)) {\n\t\t\t_nodeMap.set(node, createNodeData(invalidate));\n\t\t\tinitNode(node);\n\t\t\treturn emptyResults;\n\t\t}\n\n\t\tconst state = _nodeMap.get(node)!;\n\t\t// shallow \"clone\" the results, so no downstream manipulation can occur\n\t\tconst dragResults = assign({}, state.dragResults);\n\t\t// we are offering up an accurate delta, so we need to take the last event position and move it to the start so\n\t\t// that our deltas are calculated from the last time they are read\n\t\tstate.start = state.last;\n\t\t// reset the delta after we have read, as any future reads should have an empty delta\n\t\tstate.dragResults.delta = createPosition();\n\t\t// clear the start state\n\t\tdelete state.dragResults.start;\n\n\t\treturn dragResults;\n\t}\n}\n\nconst controller = new DragController();\n\nexport class Drag extends Base {\n\tprivate _boundInvalidate: () => void = this.invalidate.bind(this);\n\n\tpublic get(key: string | number): Readonly<DragResults> {\n\t\tconst node = this.getNode(key) as HTMLElement;\n\n\t\t// if we don't have a reference to the node yet, return an empty set of results\n\t\tif (!node) {\n\t\t\treturn emptyResults;\n\t\t}\n\n\t\t// otherwise we will ask the controller for our results\n\t\treturn controller.get(node, this._boundInvalidate);\n\t}\n}\n\nexport default Drag;\n"]}