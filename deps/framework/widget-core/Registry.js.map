{"version":3,"file":"Registry.js","sourceRoot":"","sources":["../../../../src/widget-core/Registry.ts"],"names":[],"mappings":"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","sourcesContent":["import Promise from '../shim/Promise';\nimport Map from '../shim/Map';\nimport Symbol from '../shim/Symbol';\nimport { EventObject } from '../core/interfaces';\nimport { Evented } from '../core/Evented';\nimport {\n\tConstructor,\n\tInjectorFactory,\n\tInjectorItem,\n\tRegistryLabel,\n\tWidgetBaseConstructor,\n\tWidgetBaseInterface\n} from './interfaces';\n\nexport type WidgetBaseConstructorFunction = () => Promise<WidgetBaseConstructor>;\n\nexport type ESMDefaultWidgetBaseFunction = () => Promise<ESMDefaultWidgetBase<WidgetBaseInterface>>;\n\nexport type RegistryItem =\n\t| WidgetBaseConstructor\n\t| Promise<WidgetBaseConstructor>\n\t| WidgetBaseConstructorFunction\n\t| ESMDefaultWidgetBaseFunction;\n\n/**\n * Widget base symbol type\n */\nexport const WIDGET_BASE_TYPE = Symbol('Widget Base');\n\nexport interface RegistryEventObject extends EventObject<RegistryLabel> {\n\taction: string;\n\titem: WidgetBaseConstructor | InjectorFactory;\n}\n/**\n * Widget Registry Interface\n */\nexport interface RegistryInterface {\n\t/**\n\t * Define a WidgetRegistryItem against a label\n\t *\n\t * @param label The label of the widget to register\n\t * @param registryItem The registry item to define\n\t */\n\tdefine(label: RegistryLabel, registryItem: RegistryItem): void;\n\n\t/**\n\t * Return a RegistryItem for the given label, null if an entry doesn't exist\n\t *\n\t * @param widgetLabel The label of the widget to return\n\t * @returns The RegistryItem for the widgetLabel, `null` if no entry exists\n\t */\n\tget<T extends WidgetBaseInterface = WidgetBaseInterface>(label: RegistryLabel): Constructor<T> | null;\n\n\t/**\n\t * Returns a boolean if an entry for the label exists\n\t *\n\t * @param widgetLabel The label to search for\n\t * @returns boolean indicating if a widget registry item exists\n\t */\n\thas(label: RegistryLabel): boolean;\n\n\t/**\n\t * Define an Injector against a label\n\t *\n\t * @param label The label of the injector to register\n\t * @param registryItem The injector factory\n\t */\n\tdefineInjector(label: RegistryLabel, injectorFactory: InjectorFactory): void;\n\n\t/**\n\t * Return an Injector registry item for the given label, null if an entry doesn't exist\n\t *\n\t * @param label The label of the injector to return\n\t * @returns The RegistryItem for the widgetLabel, `null` if no entry exists\n\t */\n\tgetInjector<T>(label: RegistryLabel): InjectorItem<T> | null;\n\n\t/**\n\t * Returns a boolean if an injector for the label exists\n\t *\n\t * @param widgetLabel The label to search for\n\t * @returns boolean indicating if a injector registry item exists\n\t */\n\thasInjector(label: RegistryLabel): boolean;\n}\n\n/**\n * Checks is the item is a subclass of WidgetBase (or a WidgetBase)\n *\n * @param item the item to check\n * @returns true/false indicating if the item is a WidgetBaseConstructor\n */\nexport function isWidgetBaseConstructor<T extends WidgetBaseInterface>(item: any): item is Constructor<T> {\n\treturn Boolean(item && item._type === WIDGET_BASE_TYPE);\n}\n\nexport interface ESMDefaultWidgetBase<T> {\n\tdefault: Constructor<T>;\n\t__esModule?: boolean;\n}\n\nexport function isWidgetConstructorDefaultExport<T>(item: any): item is ESMDefaultWidgetBase<T> {\n\treturn Boolean(\n\t\titem &&\n\t\t\titem.hasOwnProperty('__esModule') &&\n\t\t\titem.hasOwnProperty('default') &&\n\t\t\tisWidgetBaseConstructor(item.default)\n\t);\n}\n\n/**\n * The Registry implementation\n */\nexport class Registry extends Evented<{}, RegistryLabel, RegistryEventObject> implements RegistryInterface {\n\t/**\n\t * internal map of labels and RegistryItem\n\t */\n\tprivate _widgetRegistry: Map<RegistryLabel, RegistryItem> | undefined;\n\n\tprivate _injectorRegistry: Map<RegistryLabel, InjectorItem> | undefined;\n\n\t/**\n\t * Emit loaded event for registry label\n\t */\n\tprivate emitLoadedEvent(widgetLabel: RegistryLabel, item: WidgetBaseConstructor | InjectorItem): void {\n\t\tthis.emit({\n\t\t\ttype: widgetLabel,\n\t\t\taction: 'loaded',\n\t\t\titem\n\t\t});\n\t}\n\n\tpublic define(label: RegistryLabel, item: RegistryItem): void {\n\t\tif (this._widgetRegistry === undefined) {\n\t\t\tthis._widgetRegistry = new Map();\n\t\t}\n\n\t\tif (this._widgetRegistry.has(label)) {\n\t\t\tthrow new Error(`widget has already been registered for '${label.toString()}'`);\n\t\t}\n\n\t\tthis._widgetRegistry.set(label, item);\n\n\t\tif (item instanceof Promise) {\n\t\t\titem.then(\n\t\t\t\t(widgetCtor) => {\n\t\t\t\t\tthis._widgetRegistry!.set(label, widgetCtor);\n\t\t\t\t\tthis.emitLoadedEvent(label, widgetCtor);\n\t\t\t\t\treturn widgetCtor;\n\t\t\t\t},\n\t\t\t\t(error) => {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t);\n\t\t} else if (isWidgetBaseConstructor(item)) {\n\t\t\tthis.emitLoadedEvent(label, item);\n\t\t}\n\t}\n\n\tpublic defineInjector(label: RegistryLabel, injectorFactory: InjectorFactory): void {\n\t\tif (this._injectorRegistry === undefined) {\n\t\t\tthis._injectorRegistry = new Map();\n\t\t}\n\n\t\tif (this._injectorRegistry.has(label)) {\n\t\t\tthrow new Error(`injector has already been registered for '${label.toString()}'`);\n\t\t}\n\n\t\tconst invalidator = new Evented();\n\n\t\tconst injectorItem: InjectorItem = {\n\t\t\tinjector: injectorFactory(() => invalidator.emit({ type: 'invalidate' })),\n\t\t\tinvalidator\n\t\t};\n\n\t\tthis._injectorRegistry.set(label, injectorItem);\n\t\tthis.emitLoadedEvent(label, injectorItem);\n\t}\n\n\tpublic get<T extends WidgetBaseInterface = WidgetBaseInterface>(label: RegistryLabel): Constructor<T> | null {\n\t\tif (!this._widgetRegistry || !this.has(label)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst item = this._widgetRegistry.get(label);\n\n\t\tif (isWidgetBaseConstructor<T>(item)) {\n\t\t\treturn item;\n\t\t}\n\n\t\tif (item instanceof Promise) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst promise = (<WidgetBaseConstructorFunction>item)();\n\t\tthis._widgetRegistry.set(label, promise);\n\n\t\tpromise.then(\n\t\t\t(widgetCtor) => {\n\t\t\t\tif (isWidgetConstructorDefaultExport<T>(widgetCtor)) {\n\t\t\t\t\twidgetCtor = widgetCtor.default;\n\t\t\t\t}\n\n\t\t\t\tthis._widgetRegistry!.set(label, widgetCtor);\n\t\t\t\tthis.emitLoadedEvent(label, widgetCtor);\n\t\t\t\treturn widgetCtor;\n\t\t\t},\n\t\t\t(error) => {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\n\t\treturn null;\n\t}\n\n\tpublic getInjector<T>(label: RegistryLabel): InjectorItem<T> | null {\n\t\tif (!this._injectorRegistry || !this.hasInjector(label)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this._injectorRegistry.get(label)!;\n\t}\n\n\tpublic has(label: RegistryLabel): boolean {\n\t\treturn Boolean(this._widgetRegistry && this._widgetRegistry.has(label));\n\t}\n\n\tpublic hasInjector(label: RegistryLabel): boolean {\n\t\treturn Boolean(this._injectorRegistry && this._injectorRegistry.has(label));\n\t}\n}\n\nexport default Registry;\n"]}