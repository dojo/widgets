{"version":3,"file":"Registry.mjs","sourceRoot":"","sources":["Registry.ts"],"names":[],"mappings":"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","sourcesContent":["import Promise from '../shim/Promise';\nimport Map from '../shim/Map';\nimport Symbol from '../shim/Symbol';\nimport { EventObject } from '../core/interfaces';\nimport { Evented } from '../core/Evented';\nimport {\n\tConstructor,\n\tInjectorFactory,\n\tInjectorItem,\n\tRegistryLabel,\n\tWidgetBaseConstructor,\n\tWidgetBaseInterface\n} from './interfaces';\n\nexport type WidgetBaseConstructorFunction = () => Promise<WidgetBaseConstructor>;\n\nexport type ESMDefaultWidgetBaseFunction = () => Promise<ESMDefaultWidgetBase<WidgetBaseInterface>>;\n\nexport type RegistryItem =\n\t| WidgetBaseConstructor\n\t| Promise<WidgetBaseConstructor>\n\t| WidgetBaseConstructorFunction\n\t| ESMDefaultWidgetBaseFunction;\n\n/**\n * Widget base symbol type\n */\nexport const WIDGET_BASE_TYPE = Symbol('Widget Base');\n\nexport interface RegistryEventObject extends EventObject<RegistryLabel> {\n\taction: string;\n\titem: WidgetBaseConstructor | InjectorFactory;\n}\n/**\n * Widget Registry Interface\n */\nexport interface RegistryInterface {\n\t/**\n\t * Define a WidgetRegistryItem against a label\n\t *\n\t * @param label The label of the widget to register\n\t * @param registryItem The registry item to define\n\t */\n\tdefine(label: RegistryLabel, registryItem: RegistryItem): void;\n\n\t/**\n\t * Return a RegistryItem for the given label, null if an entry doesn't exist\n\t *\n\t * @param widgetLabel The label of the widget to return\n\t * @returns The RegistryItem for the widgetLabel, `null` if no entry exists\n\t */\n\tget<T extends WidgetBaseInterface = WidgetBaseInterface>(label: RegistryLabel): Constructor<T> | null;\n\n\t/**\n\t * Returns a boolean if an entry for the label exists\n\t *\n\t * @param widgetLabel The label to search for\n\t * @returns boolean indicating if a widget registry item exists\n\t */\n\thas(label: RegistryLabel): boolean;\n\n\t/**\n\t * Define an Injector against a label\n\t *\n\t * @param label The label of the injector to register\n\t * @param registryItem The injector factory\n\t */\n\tdefineInjector(label: RegistryLabel, injectorFactory: InjectorFactory): void;\n\n\t/**\n\t * Return an Injector registry item for the given label, null if an entry doesn't exist\n\t *\n\t * @param label The label of the injector to return\n\t * @returns The RegistryItem for the widgetLabel, `null` if no entry exists\n\t */\n\tgetInjector<T>(label: RegistryLabel): InjectorItem<T> | null;\n\n\t/**\n\t * Returns a boolean if an injector for the label exists\n\t *\n\t * @param widgetLabel The label to search for\n\t * @returns boolean indicating if a injector registry item exists\n\t */\n\thasInjector(label: RegistryLabel): boolean;\n}\n\n/**\n * Checks is the item is a subclass of WidgetBase (or a WidgetBase)\n *\n * @param item the item to check\n * @returns true/false indicating if the item is a WidgetBaseConstructor\n */\nexport function isWidgetBaseConstructor<T extends WidgetBaseInterface>(item: any): item is Constructor<T> {\n\treturn Boolean(item && item._type === WIDGET_BASE_TYPE);\n}\n\nexport interface ESMDefaultWidgetBase<T> {\n\tdefault: Constructor<T>;\n\t__esModule?: boolean;\n}\n\nexport function isWidgetConstructorDefaultExport<T>(item: any): item is ESMDefaultWidgetBase<T> {\n\treturn Boolean(\n\t\titem &&\n\t\t\titem.hasOwnProperty('__esModule') &&\n\t\t\titem.hasOwnProperty('default') &&\n\t\t\tisWidgetBaseConstructor(item.default)\n\t);\n}\n\n/**\n * The Registry implementation\n */\nexport class Registry extends Evented<{}, RegistryLabel, RegistryEventObject> implements RegistryInterface {\n\t/**\n\t * internal map of labels and RegistryItem\n\t */\n\tprivate _widgetRegistry: Map<RegistryLabel, RegistryItem> | undefined;\n\n\tprivate _injectorRegistry: Map<RegistryLabel, InjectorItem> | undefined;\n\n\t/**\n\t * Emit loaded event for registry label\n\t */\n\tprivate emitLoadedEvent(widgetLabel: RegistryLabel, item: WidgetBaseConstructor | InjectorItem): void {\n\t\tthis.emit({\n\t\t\ttype: widgetLabel,\n\t\t\taction: 'loaded',\n\t\t\titem\n\t\t});\n\t}\n\n\tpublic define(label: RegistryLabel, item: RegistryItem): void {\n\t\tif (this._widgetRegistry === undefined) {\n\t\t\tthis._widgetRegistry = new Map();\n\t\t}\n\n\t\tif (this._widgetRegistry.has(label)) {\n\t\t\tthrow new Error(`widget has already been registered for '${label.toString()}'`);\n\t\t}\n\n\t\tthis._widgetRegistry.set(label, item);\n\n\t\tif (item instanceof Promise) {\n\t\t\titem.then(\n\t\t\t\t(widgetCtor) => {\n\t\t\t\t\tthis._widgetRegistry!.set(label, widgetCtor);\n\t\t\t\t\tthis.emitLoadedEvent(label, widgetCtor);\n\t\t\t\t\treturn widgetCtor;\n\t\t\t\t},\n\t\t\t\t(error) => {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t);\n\t\t} else if (isWidgetBaseConstructor(item)) {\n\t\t\tthis.emitLoadedEvent(label, item);\n\t\t}\n\t}\n\n\tpublic defineInjector(label: RegistryLabel, injectorFactory: InjectorFactory): void {\n\t\tif (this._injectorRegistry === undefined) {\n\t\t\tthis._injectorRegistry = new Map();\n\t\t}\n\n\t\tif (this._injectorRegistry.has(label)) {\n\t\t\tthrow new Error(`injector has already been registered for '${label.toString()}'`);\n\t\t}\n\n\t\tconst invalidator = new Evented();\n\n\t\tconst injectorItem: InjectorItem = {\n\t\t\tinjector: injectorFactory(() => invalidator.emit({ type: 'invalidate' })),\n\t\t\tinvalidator\n\t\t};\n\n\t\tthis._injectorRegistry.set(label, injectorItem);\n\t\tthis.emitLoadedEvent(label, injectorItem);\n\t}\n\n\tpublic get<T extends WidgetBaseInterface = WidgetBaseInterface>(label: RegistryLabel): Constructor<T> | null {\n\t\tif (!this._widgetRegistry || !this.has(label)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst item = this._widgetRegistry.get(label);\n\n\t\tif (isWidgetBaseConstructor<T>(item)) {\n\t\t\treturn item;\n\t\t}\n\n\t\tif (item instanceof Promise) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst promise = (<WidgetBaseConstructorFunction>item)();\n\t\tthis._widgetRegistry.set(label, promise);\n\n\t\tpromise.then(\n\t\t\t(widgetCtor) => {\n\t\t\t\tif (isWidgetConstructorDefaultExport<T>(widgetCtor)) {\n\t\t\t\t\twidgetCtor = widgetCtor.default;\n\t\t\t\t}\n\n\t\t\t\tthis._widgetRegistry!.set(label, widgetCtor);\n\t\t\t\tthis.emitLoadedEvent(label, widgetCtor);\n\t\t\t\treturn widgetCtor;\n\t\t\t},\n\t\t\t(error) => {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\n\t\treturn null;\n\t}\n\n\tpublic getInjector<T>(label: RegistryLabel): InjectorItem<T> | null {\n\t\tif (!this._injectorRegistry || !this.hasInjector(label)) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this._injectorRegistry.get(label)!;\n\t}\n\n\tpublic has(label: RegistryLabel): boolean {\n\t\treturn Boolean(this._widgetRegistry && this._widgetRegistry.has(label));\n\t}\n\n\tpublic hasInjector(label: RegistryLabel): boolean {\n\t\treturn Boolean(this._injectorRegistry && this._injectorRegistry.has(label));\n\t}\n}\n\nexport default Registry;\n"]}