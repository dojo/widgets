{"version":3,"file":"StoreInjector.js","sourceRoot":"","sources":["../../../../src/stores/StoreInjector.ts"],"names":[],"mappings":"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","sourcesContent":["import WeakMap from '../shim/WeakMap';\nimport { WidgetBase } from '../widget-core/WidgetBase';\nimport { w } from '../widget-core/d';\nimport { handleDecorator } from '../widget-core/decorators/handleDecorator';\nimport { beforeProperties } from '../widget-core/decorators/beforeProperties';\nimport { alwaysRender } from '../widget-core/decorators/alwaysRender';\nimport { InjectorItem, RegistryLabel, Constructor, DNode } from '../widget-core/interfaces';\nimport { Store } from './Store';\nimport { Registry } from '../../src/widget-core/Registry';\n\nconst registeredInjectorsMap: WeakMap<WidgetBase, InjectorItem<Store>[]> = new WeakMap();\n\nexport interface GetProperties<S extends Store, W extends WidgetBase<any, any> = WidgetBase<any, any>> {\n\t(payload: S, properties: W['properties']): W['properties'];\n}\n\nexport type StoreContainerPath<\n\tS,\n\tP0 extends keyof S = keyof S,\n\tP1 extends keyof S[P0] = keyof S[P0],\n\tP2 extends keyof S[P0][P1] = keyof S[P0][P1],\n\tP3 extends keyof S[P0][P1][P2] = keyof S[P0][P1][P2],\n\tP4 extends keyof S[P0][P1][P2][P3] = keyof S[P0][P1][P2][P3]\n> = [P0] | [P0, P1] | [P0, P1, P2] | [P0, P1, P2, P3] | [P0, P1, P2, P3, P4];\n\nexport interface StoreInjectConfig<S = any> {\n\tname: RegistryLabel;\n\tgetProperties: GetProperties<Store<S>, any>;\n\tpaths?: StoreContainerPath<S>[];\n}\n\nexport type StoreContainer<T extends WidgetBase<any, any>> = Constructor<\n\tWidgetBase<Partial<T['properties']>, T['children'][0]>\n>;\n\n/**\n * Decorator that registers a store injector with a container based on paths when provided\n *\n * @param config Configuration of the store injector\n */\nexport function storeInject<S>(config: StoreInjectConfig<S>) {\n\tconst { name, paths, getProperties } = config;\n\n\treturn handleDecorator((target, propertyKey) => {\n\t\tbeforeProperties(function(this: WidgetBase & { own: Function }, properties: any) {\n\t\t\tconst injectorItem = this.registry.getInjector<Store<S>>(name);\n\t\t\tif (injectorItem) {\n\t\t\t\tconst { injector } = injectorItem;\n\t\t\t\tconst store = injector();\n\t\t\t\tconst registeredInjectors = registeredInjectorsMap.get(this) || [];\n\t\t\t\tif (registeredInjectors.length === 0) {\n\t\t\t\t\tregisteredInjectorsMap.set(this, registeredInjectors);\n\t\t\t\t}\n\t\t\t\tif (registeredInjectors.indexOf(injectorItem) === -1) {\n\t\t\t\t\tif (paths) {\n\t\t\t\t\t\tconst handle = store.onChange(paths.map((path: any) => store.path(path.join('/'))), () =>\n\t\t\t\t\t\t\tthis.invalidate()\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.own({\n\t\t\t\t\t\t\tdestroy: () => {\n\t\t\t\t\t\t\t\thandle.remove();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.own(\n\t\t\t\t\t\t\tstore.on('invalidate', () => {\n\t\t\t\t\t\t\t\tthis.invalidate();\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tregisteredInjectors.push(injectorItem);\n\t\t\t\t}\n\t\t\t\treturn getProperties(store, properties);\n\t\t\t}\n\t\t})(target);\n\t});\n}\n\nexport function StoreContainer<S = any, W extends WidgetBase<any, any> = WidgetBase<any, any>>(\n\tcomponent: Constructor<W> | RegistryLabel,\n\tname: RegistryLabel,\n\t{ paths, getProperties }: { paths?: StoreContainerPath<S>[]; getProperties: GetProperties<Store<S>, W> }\n): StoreContainer<W> {\n\t@alwaysRender()\n\t@storeInject({ name, paths, getProperties })\n\tclass WidgetContainer extends WidgetBase<Partial<W['properties']>, W['children'][0]> {\n\t\tprotected render(): DNode {\n\t\t\treturn w(component, this.properties, this.children);\n\t\t}\n\t}\n\treturn WidgetContainer;\n}\n\n/**\n * Creates a typed `StoreContainer` for State generic.\n */\nexport function createStoreContainer<S>() {\n\treturn <W extends WidgetBase<any, any>>(\n\t\tcomponent: Constructor<W> | RegistryLabel,\n\t\tname: RegistryLabel,\n\t\t{ paths, getProperties }: { paths?: StoreContainerPath<S>[]; getProperties: GetProperties<Store<S>, W> }\n\t) => {\n\t\treturn StoreContainer(component, name, { paths, getProperties });\n\t};\n}\n\nexport interface StoreInjectorOptions {\n\tkey?: RegistryLabel;\n\tregistry?: Registry;\n}\n\nexport function registerStoreInjector<T>(store: Store<T>, options: StoreInjectorOptions = {}) {\n\tconst { key = 'state', registry = new Registry() } = options;\n\n\tif (registry.hasInjector(key)) {\n\t\tthrow new Error(`Store has already been defined for key ${key.toString()}`);\n\t}\n\tregistry.defineInjector(key, () => {\n\t\treturn () => store;\n\t});\n\treturn registry;\n}\n"]}