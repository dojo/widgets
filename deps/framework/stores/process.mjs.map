{"version":3,"file":"process.mjs","sourceRoot":"","sources":["process.ts"],"names":[],"mappings":"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","sourcesContent":["import { isThenable } from '../shim/Promise';\nimport { PatchOperation } from './state/Patch';\nimport { State, Store } from './Store';\nimport Map from '../shim/Map';\n\n/**\n * Default Payload interface\n */\nexport interface DefaultPayload {\n\t[index: string]: any;\n}\n\n/**\n * The arguments passed to a `Command`\n */\nexport interface CommandRequest<T = any, P extends object = DefaultPayload> extends State<T> {\n\tpayload: P;\n}\n\n/**\n * A command factory interface. Returns the passed command. This provides a way to automatically infer and/or\n * verify the type of multiple commands without explicitly specifying the generic for each command\n */\nexport interface CommandFactory<T = any, P extends object = DefaultPayload> {\n\t<R extends object = P>(command: Command<T, R>): Command<T, R>;\n}\n\n/**\n * Command that returns patch operations based on the command request\n */\nexport interface Command<T = any, P extends object = DefaultPayload> {\n\t(request: CommandRequest<T, P>): Promise<PatchOperation<T>[]> | PatchOperation<T>[];\n}\n\n/**\n * Transformer function\n */\nexport interface Transformer<P extends object = DefaultPayload, R extends object = DefaultPayload> {\n\t(payload: R): P;\n}\n\n/**\n * A process that returns an executor using a Store and Transformer\n */\nexport interface Process<T = any, P extends object = DefaultPayload> {\n\t<R extends object = DefaultPayload>(store: Store<T>, transformer: Transformer<P, R>): ProcessExecutor<T, P, R>;\n\t(store: Store<T>): ProcessExecutor<T, P, P>;\n}\n\n/**\n * Represents an error from a ProcessExecutor\n */\nexport interface ProcessError<T = any> {\n\terror: Error | null;\n\tcommand?: Command<T, any>[] | Command<T, any>;\n}\n\nexport interface ProcessResultExecutor<T = any> {\n\t<P extends object = DefaultPayload, R extends object = DefaultPayload>(\n\t\tprocess: Process<T, P>,\n\t\tpayload: R,\n\t\ttransformer: Transformer<P, R>\n\t): Promise<ProcessResult<T, P> | ProcessError<T>>;\n\t<P extends object = object>(process: Process<T, P>, payload: P): Promise<ProcessResult<T, P> | ProcessError<T>>;\n}\n\n/**\n * Represents a successful result from a ProcessExecutor\n */\nexport interface ProcessResult<T = any, P extends object = DefaultPayload> extends State<T> {\n\texecutor: ProcessResultExecutor<T>;\n\tstore: Store<T>;\n\toperations: PatchOperation<T>[];\n\tundoOperations: PatchOperation<T>[];\n\tapply: (operations: PatchOperation<T>[], invalidate?: boolean) => PatchOperation<T>[];\n\tpayload: P;\n\tid: string;\n\terror?: ProcessError<T> | null;\n}\n\n/**\n * Runs a process for the given arguments.\n */\nexport interface ProcessExecutor<T = any, P extends object = DefaultPayload, R extends object = DefaultPayload> {\n\t(payload: R): Promise<ProcessResult<T, P>>;\n}\n\n/**\n * Callback for a process, returns an error as the first argument\n */\nexport interface ProcessCallback<T = any> {\n\t(error: ProcessError<T> | null, result: ProcessResult<T>): void;\n}\n\n/**\n * Function for undoing operations\n */\nexport interface Undo {\n\t(): void;\n}\n\n/**\n * ProcessCallbackDecorator callback\n */\nexport interface ProcessCallbackDecorator {\n\t(callback?: ProcessCallback): ProcessCallback;\n}\n\n/**\n * CreateProcess factory interface\n */\nexport interface CreateProcess<T = any, P extends object = DefaultPayload> {\n\t(id: string, commands: (Command<T, P>[] | Command<T, P>)[], callback?: ProcessCallback<T>): Process<T, P>;\n}\n\n/**\n * Creates a command factory with the specified type\n */\nexport function createCommandFactory<T, P extends object = DefaultPayload>(): CommandFactory<T, P> {\n\treturn <R extends object = P>(command: Command<T, R>) => command;\n}\n\n/**\n * Commands that can be passed to a process\n */\nexport type Commands<T = any, P extends object = DefaultPayload> = (Command<T, P>[] | Command<T, P>)[];\n\nconst processMap = new Map();\n\nexport function getProcess(id: string) {\n\treturn processMap.get(id);\n}\n\nexport function processExecutor<T = any, P extends object = DefaultPayload>(\n\tid: string,\n\tcommands: Commands<T, P>,\n\tstore: Store<T>,\n\tcallback: ProcessCallback | undefined,\n\ttransformer: Transformer<P> | undefined\n): ProcessExecutor<T, any, any> {\n\tconst { apply, get, path, at } = store;\n\tfunction executor(\n\t\tprocess: Process,\n\t\tpayload: any,\n\t\ttransformer?: Transformer\n\t): Promise<ProcessResult | ProcessError> {\n\t\treturn process(store)(payload);\n\t}\n\n\treturn async (executorPayload: P): Promise<ProcessResult<T, P>> => {\n\t\tconst operations: PatchOperation[] = [];\n\t\tconst commandsCopy = [...commands];\n\t\tlet undoOperations: PatchOperation[] = [];\n\t\tlet command = commandsCopy.shift();\n\t\tlet error: ProcessError | null = null;\n\t\tconst payload = transformer ? transformer(executorPayload) : executorPayload;\n\t\ttry {\n\t\t\twhile (command) {\n\t\t\t\tlet results = [];\n\t\t\t\tif (Array.isArray(command)) {\n\t\t\t\t\tresults = command.map((commandFunction) => commandFunction({ at, get, path, payload }));\n\t\t\t\t\tresults = await Promise.all(results);\n\t\t\t\t} else {\n\t\t\t\t\tlet result = command({ at, get, path, payload });\n\t\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\t\tresult = await result;\n\t\t\t\t\t}\n\t\t\t\t\tresults = [result];\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\toperations.push(...results[i]);\n\t\t\t\t\tundoOperations = [...apply(results[i]), ...undoOperations];\n\t\t\t\t}\n\n\t\t\t\tstore.invalidate();\n\t\t\t\tcommand = commandsCopy.shift();\n\t\t\t}\n\t\t} catch (e) {\n\t\t\terror = { error: e, command };\n\t\t}\n\n\t\tcallback &&\n\t\t\tcallback(error, {\n\t\t\t\tundoOperations,\n\t\t\t\tstore,\n\t\t\t\tid,\n\t\t\t\toperations,\n\t\t\t\tapply,\n\t\t\t\tat,\n\t\t\t\tget,\n\t\t\t\tpath,\n\t\t\t\texecutor,\n\t\t\t\tpayload\n\t\t\t});\n\t\treturn Promise.resolve({\n\t\t\tstore,\n\t\t\tundoOperations,\n\t\t\tid,\n\t\t\terror,\n\t\t\toperations,\n\t\t\tapply,\n\t\t\tat,\n\t\t\tget,\n\t\t\tpath,\n\t\t\texecutor,\n\t\t\tpayload\n\t\t});\n\t};\n}\n/**\n * Factories a process using the provided commands and an optional callback. Returns an executor used to run the process.\n *\n * @param commands The commands for the process\n * @param callback Callback called after the process is completed\n */\nexport function createProcess<T = any, P extends object = DefaultPayload>(\n\tid: string,\n\tcommands: Commands<T, P>,\n\tcallback?: ProcessCallback\n): Process<T, P> {\n\tprocessMap.set(id, [id, commands, callback]);\n\treturn (store: Store<T>, transformer?: Transformer<P>) =>\n\t\tprocessExecutor(id, commands, store, callback, transformer);\n}\n\n/**\n * Creates a process factory that will create processes with the specified callback decorators applied.\n * @param callbackDecorators array of process callback decorators to be used by the return factory.\n */\nexport function createProcessFactoryWith(callbackDecorators: ProcessCallbackDecorator[]): CreateProcess {\n\treturn (id: string, commands: (Command[] | Command)[], callback?: ProcessCallback): Process => {\n\t\tconst decoratedCallback = callbackDecorators.reduce((callback, callbackDecorator) => {\n\t\t\treturn callbackDecorator(callback);\n\t\t}, callback);\n\t\treturn createProcess(id, commands, decoratedCallback);\n\t};\n}\n\n/**\n * Creates a `ProcessCallbackDecorator` from a `ProcessCallback`.\n * @param processCallback the process callback to convert to a decorator.\n */\nexport function createCallbackDecorator(processCallback: ProcessCallback): ProcessCallbackDecorator {\n\treturn (previousCallback?: ProcessCallback): ProcessCallback => {\n\t\treturn (error: ProcessError | null, result: ProcessResult): void => {\n\t\t\tprocessCallback(error, result);\n\t\t\tpreviousCallback && previousCallback(error, result);\n\t\t};\n\t};\n}\n"]}