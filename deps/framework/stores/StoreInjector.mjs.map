{"version":3,"file":"StoreInjector.mjs","sourceRoot":"","sources":["../../../../src/stores/StoreInjector.ts"],"names":[],"mappings":"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","sourcesContent":["import WeakMap from '../shim/WeakMap';\nimport { WidgetBase } from '../widget-core/WidgetBase';\nimport { w } from '../widget-core/d';\nimport { handleDecorator } from '../widget-core/decorators/handleDecorator';\nimport { beforeProperties } from '../widget-core/decorators/beforeProperties';\nimport { alwaysRender } from '../widget-core/decorators/alwaysRender';\nimport { InjectorItem, RegistryLabel, Constructor, DNode } from '../widget-core/interfaces';\nimport { Store } from './Store';\nimport { Registry } from '../../src/widget-core/Registry';\n\nconst registeredInjectorsMap: WeakMap<WidgetBase, InjectorItem<Store>[]> = new WeakMap();\n\nexport interface GetProperties<S extends Store, W extends WidgetBase<any, any> = WidgetBase<any, any>> {\n\t(payload: S, properties: W['properties']): W['properties'];\n}\n\nexport type StoreContainerPath<\n\tS,\n\tP0 extends keyof S = keyof S,\n\tP1 extends keyof S[P0] = keyof S[P0],\n\tP2 extends keyof S[P0][P1] = keyof S[P0][P1],\n\tP3 extends keyof S[P0][P1][P2] = keyof S[P0][P1][P2],\n\tP4 extends keyof S[P0][P1][P2][P3] = keyof S[P0][P1][P2][P3]\n> = [P0] | [P0, P1] | [P0, P1, P2] | [P0, P1, P2, P3] | [P0, P1, P2, P3, P4];\n\nexport interface StoreInjectConfig<S = any> {\n\tname: RegistryLabel;\n\tgetProperties: GetProperties<Store<S>, any>;\n\tpaths?: StoreContainerPath<S>[];\n}\n\nexport type StoreContainer<T extends WidgetBase<any, any>> = Constructor<\n\tWidgetBase<Partial<T['properties']>, T['children'][0]>\n>;\n\n/**\n * Decorator that registers a store injector with a container based on paths when provided\n *\n * @param config Configuration of the store injector\n */\nexport function storeInject<S>(config: StoreInjectConfig<S>) {\n\tconst { name, paths, getProperties } = config;\n\n\treturn handleDecorator((target, propertyKey) => {\n\t\tbeforeProperties(function(this: WidgetBase & { own: Function }, properties: any) {\n\t\t\tconst injectorItem = this.registry.getInjector<Store<S>>(name);\n\t\t\tif (injectorItem) {\n\t\t\t\tconst { injector } = injectorItem;\n\t\t\t\tconst store = injector();\n\t\t\t\tconst registeredInjectors = registeredInjectorsMap.get(this) || [];\n\t\t\t\tif (registeredInjectors.length === 0) {\n\t\t\t\t\tregisteredInjectorsMap.set(this, registeredInjectors);\n\t\t\t\t}\n\t\t\t\tif (registeredInjectors.indexOf(injectorItem) === -1) {\n\t\t\t\t\tif (paths) {\n\t\t\t\t\t\tconst handle = store.onChange(paths.map((path: any) => store.path(path.join('/'))), () =>\n\t\t\t\t\t\t\tthis.invalidate()\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.own({\n\t\t\t\t\t\t\tdestroy: () => {\n\t\t\t\t\t\t\t\thandle.remove();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.own(\n\t\t\t\t\t\t\tstore.on('invalidate', () => {\n\t\t\t\t\t\t\t\tthis.invalidate();\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tregisteredInjectors.push(injectorItem);\n\t\t\t\t}\n\t\t\t\treturn getProperties(store, properties);\n\t\t\t}\n\t\t})(target);\n\t});\n}\n\nexport function StoreContainer<S = any, W extends WidgetBase<any, any> = WidgetBase<any, any>>(\n\tcomponent: Constructor<W> | RegistryLabel,\n\tname: RegistryLabel,\n\t{ paths, getProperties }: { paths?: StoreContainerPath<S>[]; getProperties: GetProperties<Store<S>, W> }\n): StoreContainer<W> {\n\t@alwaysRender()\n\t@storeInject({ name, paths, getProperties })\n\tclass WidgetContainer extends WidgetBase<Partial<W['properties']>, W['children'][0]> {\n\t\tprotected render(): DNode {\n\t\t\treturn w(component, this.properties, this.children);\n\t\t}\n\t}\n\treturn WidgetContainer;\n}\n\n/**\n * Creates a typed `StoreContainer` for State generic.\n */\nexport function createStoreContainer<S>() {\n\treturn <W extends WidgetBase<any, any>>(\n\t\tcomponent: Constructor<W> | RegistryLabel,\n\t\tname: RegistryLabel,\n\t\t{ paths, getProperties }: { paths?: StoreContainerPath<S>[]; getProperties: GetProperties<Store<S>, W> }\n\t) => {\n\t\treturn StoreContainer(component, name, { paths, getProperties });\n\t};\n}\n\nexport interface StoreInjectorOptions {\n\tkey?: RegistryLabel;\n\tregistry?: Registry;\n}\n\nexport function registerStoreInjector<T>(store: Store<T>, options: StoreInjectorOptions = {}) {\n\tconst { key = 'state', registry = new Registry() } = options;\n\n\tif (registry.hasInjector(key)) {\n\t\tthrow new Error(`Store has already been defined for key ${key.toString()}`);\n\t}\n\tregistry.defineInjector(key, () => {\n\t\treturn () => store;\n\t});\n\treturn registry;\n}\n"]}