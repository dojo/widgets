{"version":3,"file":"Promise.mjs","sourceRoot":"","sources":["../../../../src/shim/Promise.ts"],"names":[],"mappings":"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","sourcesContent":["import { Thenable } from './interfaces';\nimport global from './global';\nimport { queueMicroTask } from './support/queue';\nimport { Iterable } from './iterator';\nimport './Symbol';\nimport has from './support/has';\n\n/**\n * Executor is the interface for functions used to initialize a Promise.\n */\nexport interface Executor<T> {\n\t/**\n\t * The executor for the promise\n\t *\n\t * @param resolve The resolver callback of the promise\n\t * @param reject The rejector callback of the promise\n\t */\n\t(resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void): void;\n}\n\nexport let ShimPromise: typeof Promise = global.Promise;\n\nexport const isThenable = function isThenable<T>(value: any): value is PromiseLike<T> {\n\treturn value && typeof value.then === 'function';\n};\n\nif (!has('es6-promise')) {\n\tconst enum State {\n\t\tFulfilled,\n\t\tPending,\n\t\tRejected\n\t}\n\n\tglobal.Promise = ShimPromise = class Promise<T> implements Thenable<T> {\n\t\tstatic all(iterable: Iterable<any | PromiseLike<any>> | (any | PromiseLike<any>)[]): Promise<any> {\n\t\t\treturn new this(function(resolve, reject) {\n\t\t\t\tconst values: any[] = [];\n\t\t\t\tlet complete = 0;\n\t\t\t\tlet total = 0;\n\t\t\t\tlet populating = true;\n\n\t\t\t\tfunction fulfill(index: number, value: any): void {\n\t\t\t\t\tvalues[index] = value;\n\t\t\t\t\t++complete;\n\t\t\t\t\tfinish();\n\t\t\t\t}\n\n\t\t\t\tfunction finish(): void {\n\t\t\t\t\tif (populating || complete < total) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tresolve(values);\n\t\t\t\t}\n\n\t\t\t\tfunction processItem(index: number, item: any): void {\n\t\t\t\t\t++total;\n\t\t\t\t\tif (isThenable(item)) {\n\t\t\t\t\t\t// If an item Promise rejects, this Promise is immediately rejected with the item\n\t\t\t\t\t\t// Promise's rejection error.\n\t\t\t\t\t\titem.then(fulfill.bind(null, index), reject);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPromise.resolve(item).then(fulfill.bind(null, index));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet i = 0;\n\t\t\t\tfor (const value of iterable) {\n\t\t\t\t\tprocessItem(i, value);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tpopulating = false;\n\n\t\t\t\tfinish();\n\t\t\t});\n\t\t}\n\n\t\tstatic race<T>(iterable: Iterable<T | PromiseLike<T>> | (T | PromiseLike<T>)[]): Promise<T[]> {\n\t\t\treturn new this(function(resolve: (value?: any) => void, reject) {\n\t\t\t\tfor (const item of iterable) {\n\t\t\t\t\tif (item instanceof Promise) {\n\t\t\t\t\t\t// If a Promise item rejects, this Promise is immediately rejected with the item\n\t\t\t\t\t\t// Promise's rejection error.\n\t\t\t\t\t\titem.then(resolve, reject);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPromise.resolve(item).then(resolve);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tstatic reject(reason?: any): Promise<never> {\n\t\t\treturn new this(function(resolve, reject) {\n\t\t\t\treject(reason);\n\t\t\t});\n\t\t}\n\n\t\tstatic resolve(): Promise<void>;\n\t\tstatic resolve<T>(value: T | PromiseLike<T>): Promise<T>;\n\t\tstatic resolve<T>(value?: any): Promise<T> {\n\t\t\treturn new this(function(resolve) {\n\t\t\t\tresolve(<T>value);\n\t\t\t});\n\t\t}\n\n\t\tstatic [Symbol.species]: PromiseConstructor = ShimPromise as PromiseConstructor;\n\n\t\t/**\n\t\t * Creates a new Promise.\n\t\t *\n\t\t * @constructor\n\t\t *\n\t\t * @param executor\n\t\t * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t\t * starting the asynchronous operation when it is invoked.\n\t\t *\n\t\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t\t * successfully, or the `reject` function when the operation fails.\n\t\t */\n\t\tconstructor(executor: Executor<T>) {\n\t\t\t/**\n\t\t\t * If true, the resolution of this promise is chained (\"locked in\") to another promise.\n\t\t\t */\n\t\t\tlet isChained = false;\n\n\t\t\t/**\n\t\t\t * Whether or not this promise is in a resolved state.\n\t\t\t */\n\t\t\tconst isResolved = (): boolean => {\n\t\t\t\treturn this.state !== State.Pending || isChained;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Callbacks that should be invoked once the asynchronous operation has completed.\n\t\t\t */\n\t\t\tlet callbacks: null | (Array<() => void>) = [];\n\n\t\t\t/**\n\t\t\t * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,\n\t\t\t * enqueues callbacks for execution on the next event loop turn.\n\t\t\t */\n\t\t\tlet whenFinished = function(callback: () => void): void {\n\t\t\t\tif (callbacks) {\n\t\t\t\t\tcallbacks.push(callback);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Settles this promise.\n\t\t\t *\n\t\t\t * @param newState The resolved state for this promise.\n\t\t\t * @param {T|any} value The resolved value for this promise.\n\t\t\t */\n\t\t\tconst settle = (newState: State, value: any): void => {\n\t\t\t\t// A promise can only be settled once.\n\t\t\t\tif (this.state !== State.Pending) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.state = newState;\n\t\t\t\tthis.resolvedValue = value;\n\t\t\t\twhenFinished = queueMicroTask;\n\n\t\t\t\t// Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to\n\t\t\t\t// wait an extra turn.\n\t\t\t\tif (callbacks && callbacks.length > 0) {\n\t\t\t\t\tqueueMicroTask(function(): void {\n\t\t\t\t\t\tif (callbacks) {\n\t\t\t\t\t\t\tlet count = callbacks.length;\n\t\t\t\t\t\t\tfor (let i = 0; i < count; ++i) {\n\t\t\t\t\t\t\t\tcallbacks[i].call(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallbacks = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Resolves this promise.\n\t\t\t *\n\t\t\t * @param newState The resolved state for this promise.\n\t\t\t * @param {T|any} value The resolved value for this promise.\n\t\t\t */\n\t\t\tconst resolve = (newState: State, value: any): void => {\n\t\t\t\tif (isResolved()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isThenable(value)) {\n\t\t\t\t\tvalue.then(settle.bind(null, State.Fulfilled), settle.bind(null, State.Rejected));\n\t\t\t\t\tisChained = true;\n\t\t\t\t} else {\n\t\t\t\t\tsettle(newState, value);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.then = <TResult1 = T, TResult2 = never>(\n\t\t\t\tonFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n\t\t\t\tonRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n\t\t\t): Promise<TResult1 | TResult2> => {\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\t// whenFinished initially queues up callbacks for execution after the promise has settled. Once the\n\t\t\t\t\t// promise has settled, whenFinished will schedule callbacks for execution on the next turn through the\n\t\t\t\t\t// event loop.\n\t\t\t\t\twhenFinished(() => {\n\t\t\t\t\t\tconst callback: ((value?: any) => any) | undefined | null =\n\t\t\t\t\t\t\tthis.state === State.Rejected ? onRejected : onFulfilled;\n\n\t\t\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresolve(callback(this.resolvedValue));\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (this.state === State.Rejected) {\n\t\t\t\t\t\t\treject(this.resolvedValue);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(this.resolvedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\texecutor(resolve.bind(null, State.Fulfilled), resolve.bind(null, State.Rejected));\n\t\t\t} catch (error) {\n\t\t\t\tsettle(State.Rejected, error);\n\t\t\t}\n\t\t}\n\n\t\tcatch<TResult = never>(\n\t\t\tonRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null\n\t\t): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, onRejected);\n\t\t}\n\n\t\t/**\n\t\t * The current state of this promise.\n\t\t */\n\t\tprivate state = State.Pending;\n\n\t\t/**\n\t\t * The resolved value for this promise.\n\t\t *\n\t\t * @type {T|any}\n\t\t */\n\t\tprivate resolvedValue: any;\n\n\t\tthen: <TResult1 = T, TResult2 = never>(\n\t\t\tonfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n\t\t\tonrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n\t\t) => Promise<TResult1 | TResult2>;\n\n\t\t[Symbol.toStringTag]: 'Promise' = 'Promise';\n\t};\n}\n\nexport default ShimPromise;\n"]}