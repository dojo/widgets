{"version":3,"file":"Promise.js","sourceRoot":"","sources":["Promise.ts"],"names":[],"mappings":"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","sourcesContent":["import { Thenable } from './interfaces';\nimport global from './global';\nimport { queueMicroTask } from './support/queue';\nimport { Iterable } from './iterator';\nimport './Symbol';\nimport has from './support/has';\n\n/**\n * Executor is the interface for functions used to initialize a Promise.\n */\nexport interface Executor<T> {\n\t/**\n\t * The executor for the promise\n\t *\n\t * @param resolve The resolver callback of the promise\n\t * @param reject The rejector callback of the promise\n\t */\n\t(resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void): void;\n}\n\nexport let ShimPromise: typeof Promise = global.Promise;\n\nexport const isThenable = function isThenable<T>(value: any): value is PromiseLike<T> {\n\treturn value && typeof value.then === 'function';\n};\n\nif (!has('es6-promise')) {\n\tconst enum State {\n\t\tFulfilled,\n\t\tPending,\n\t\tRejected\n\t}\n\n\tglobal.Promise = ShimPromise = class Promise<T> implements Thenable<T> {\n\t\tstatic all(iterable: Iterable<any | PromiseLike<any>> | (any | PromiseLike<any>)[]): Promise<any> {\n\t\t\treturn new this(function(resolve, reject) {\n\t\t\t\tconst values: any[] = [];\n\t\t\t\tlet complete = 0;\n\t\t\t\tlet total = 0;\n\t\t\t\tlet populating = true;\n\n\t\t\t\tfunction fulfill(index: number, value: any): void {\n\t\t\t\t\tvalues[index] = value;\n\t\t\t\t\t++complete;\n\t\t\t\t\tfinish();\n\t\t\t\t}\n\n\t\t\t\tfunction finish(): void {\n\t\t\t\t\tif (populating || complete < total) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tresolve(values);\n\t\t\t\t}\n\n\t\t\t\tfunction processItem(index: number, item: any): void {\n\t\t\t\t\t++total;\n\t\t\t\t\tif (isThenable(item)) {\n\t\t\t\t\t\t// If an item Promise rejects, this Promise is immediately rejected with the item\n\t\t\t\t\t\t// Promise's rejection error.\n\t\t\t\t\t\titem.then(fulfill.bind(null, index), reject);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPromise.resolve(item).then(fulfill.bind(null, index));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet i = 0;\n\t\t\t\tfor (const value of iterable) {\n\t\t\t\t\tprocessItem(i, value);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tpopulating = false;\n\n\t\t\t\tfinish();\n\t\t\t});\n\t\t}\n\n\t\tstatic race<T>(iterable: Iterable<T | PromiseLike<T>> | (T | PromiseLike<T>)[]): Promise<T[]> {\n\t\t\treturn new this(function(resolve: (value?: any) => void, reject) {\n\t\t\t\tfor (const item of iterable) {\n\t\t\t\t\tif (item instanceof Promise) {\n\t\t\t\t\t\t// If a Promise item rejects, this Promise is immediately rejected with the item\n\t\t\t\t\t\t// Promise's rejection error.\n\t\t\t\t\t\titem.then(resolve, reject);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPromise.resolve(item).then(resolve);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tstatic reject(reason?: any): Promise<never> {\n\t\t\treturn new this(function(resolve, reject) {\n\t\t\t\treject(reason);\n\t\t\t});\n\t\t}\n\n\t\tstatic resolve(): Promise<void>;\n\t\tstatic resolve<T>(value: T | PromiseLike<T>): Promise<T>;\n\t\tstatic resolve<T>(value?: any): Promise<T> {\n\t\t\treturn new this(function(resolve) {\n\t\t\t\tresolve(<T>value);\n\t\t\t});\n\t\t}\n\n\t\tstatic [Symbol.species]: PromiseConstructor = ShimPromise as PromiseConstructor;\n\n\t\t/**\n\t\t * Creates a new Promise.\n\t\t *\n\t\t * @constructor\n\t\t *\n\t\t * @param executor\n\t\t * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t\t * starting the asynchronous operation when it is invoked.\n\t\t *\n\t\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t\t * successfully, or the `reject` function when the operation fails.\n\t\t */\n\t\tconstructor(executor: Executor<T>) {\n\t\t\t/**\n\t\t\t * If true, the resolution of this promise is chained (\"locked in\") to another promise.\n\t\t\t */\n\t\t\tlet isChained = false;\n\n\t\t\t/**\n\t\t\t * Whether or not this promise is in a resolved state.\n\t\t\t */\n\t\t\tconst isResolved = (): boolean => {\n\t\t\t\treturn this.state !== State.Pending || isChained;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Callbacks that should be invoked once the asynchronous operation has completed.\n\t\t\t */\n\t\t\tlet callbacks: null | (Array<() => void>) = [];\n\n\t\t\t/**\n\t\t\t * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,\n\t\t\t * enqueues callbacks for execution on the next event loop turn.\n\t\t\t */\n\t\t\tlet whenFinished = function(callback: () => void): void {\n\t\t\t\tif (callbacks) {\n\t\t\t\t\tcallbacks.push(callback);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Settles this promise.\n\t\t\t *\n\t\t\t * @param newState The resolved state for this promise.\n\t\t\t * @param {T|any} value The resolved value for this promise.\n\t\t\t */\n\t\t\tconst settle = (newState: State, value: any): void => {\n\t\t\t\t// A promise can only be settled once.\n\t\t\t\tif (this.state !== State.Pending) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.state = newState;\n\t\t\t\tthis.resolvedValue = value;\n\t\t\t\twhenFinished = queueMicroTask;\n\n\t\t\t\t// Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to\n\t\t\t\t// wait an extra turn.\n\t\t\t\tif (callbacks && callbacks.length > 0) {\n\t\t\t\t\tqueueMicroTask(function(): void {\n\t\t\t\t\t\tif (callbacks) {\n\t\t\t\t\t\t\tlet count = callbacks.length;\n\t\t\t\t\t\t\tfor (let i = 0; i < count; ++i) {\n\t\t\t\t\t\t\t\tcallbacks[i].call(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallbacks = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Resolves this promise.\n\t\t\t *\n\t\t\t * @param newState The resolved state for this promise.\n\t\t\t * @param {T|any} value The resolved value for this promise.\n\t\t\t */\n\t\t\tconst resolve = (newState: State, value: any): void => {\n\t\t\t\tif (isResolved()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isThenable(value)) {\n\t\t\t\t\tvalue.then(settle.bind(null, State.Fulfilled), settle.bind(null, State.Rejected));\n\t\t\t\t\tisChained = true;\n\t\t\t\t} else {\n\t\t\t\t\tsettle(newState, value);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.then = <TResult1 = T, TResult2 = never>(\n\t\t\t\tonFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n\t\t\t\tonRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n\t\t\t): Promise<TResult1 | TResult2> => {\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\t// whenFinished initially queues up callbacks for execution after the promise has settled. Once the\n\t\t\t\t\t// promise has settled, whenFinished will schedule callbacks for execution on the next turn through the\n\t\t\t\t\t// event loop.\n\t\t\t\t\twhenFinished(() => {\n\t\t\t\t\t\tconst callback: ((value?: any) => any) | undefined | null =\n\t\t\t\t\t\t\tthis.state === State.Rejected ? onRejected : onFulfilled;\n\n\t\t\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresolve(callback(this.resolvedValue));\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (this.state === State.Rejected) {\n\t\t\t\t\t\t\treject(this.resolvedValue);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(this.resolvedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\texecutor(resolve.bind(null, State.Fulfilled), resolve.bind(null, State.Rejected));\n\t\t\t} catch (error) {\n\t\t\t\tsettle(State.Rejected, error);\n\t\t\t}\n\t\t}\n\n\t\tcatch<TResult = never>(\n\t\t\tonRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null\n\t\t): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, onRejected);\n\t\t}\n\n\t\t/**\n\t\t * The current state of this promise.\n\t\t */\n\t\tprivate state = State.Pending;\n\n\t\t/**\n\t\t * The resolved value for this promise.\n\t\t *\n\t\t * @type {T|any}\n\t\t */\n\t\tprivate resolvedValue: any;\n\n\t\tthen: <TResult1 = T, TResult2 = never>(\n\t\t\tonfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n\t\t\tonrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n\t\t) => Promise<TResult1 | TResult2>;\n\n\t\t[Symbol.toStringTag]: 'Promise' = 'Promise';\n\t};\n}\n\nexport default ShimPromise;\n"]}