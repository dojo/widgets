{"version":3,"file":"util.js","sourceRoot":"","sources":["util.ts"],"names":[],"mappings":";;;;;;;;;;;IAAA;;;;;;;;OAQG;IACH,4BACC,KAAQ,EACR,UAA2B,EAC3B,QAAwB,EACxB,YAA4B;QAF5B,2BAAA,EAAA,kBAA2B;QAC3B,yBAAA,EAAA,eAAwB;QACxB,6BAAA,EAAA,mBAA4B;QAE5B,MAAM,CAAC;YACN,KAAK,EAAE,KAAK;YACZ,UAAU,EAAE,UAAU;YACtB,QAAQ,EAAE,QAAQ;YAClB,YAAY,EAAE,YAAY;SAC1B,CAAC;IACH,CAAC;IAZD,gDAYC;IAmBD,oBAA2B,cAAuC;QACjE,MAAM,CAAC,UAAS,MAAW;YAAE,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,6BAAc;;YAC1C,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QAC3C,CAAC,CAAC;IACH,CAAC;IAJD,gCAIC","sourcesContent":["/**\n * Helper function to generate a value property descriptor\n *\n * @param value        The value the property descriptor should be set to\n * @param enumerable   If the property should be enumberable, defaults to false\n * @param writable     If the property should be writable, defaults to true\n * @param configurable If the property should be configurable, defaults to true\n * @return             The property descriptor object\n */\nexport function getValueDescriptor<T>(\n\tvalue: T,\n\tenumerable: boolean = false,\n\twritable: boolean = true,\n\tconfigurable: boolean = true\n): TypedPropertyDescriptor<T> {\n\treturn {\n\t\tvalue: value,\n\t\tenumerable: enumerable,\n\t\twritable: writable,\n\t\tconfigurable: configurable\n\t};\n}\n\n/**\n * A helper function which wraps a function where the first argument becomes the scope\n * of the call\n *\n * @param nativeFunction The source function to be wrapped\n */\nexport function wrapNative<T, U, R>(nativeFunction: (arg1: U) => R): (target: T, arg1: U) => R;\nexport function wrapNative<T, U, V, R>(nativeFunction: (arg1: U, arg2: V) => R): (target: T, arg1: U, arg2: V) => R;\nexport function wrapNative<T, U, V, W, R>(\n\tnativeFunction: (arg1: U, arg2: V, arg3: W) => R\n): (target: T, arg1: U, arg2: V, arg3: W) => R;\nexport function wrapNative<T, U, V, W, X, R>(\n\tnativeFunction: (arg1: U, arg2: V, arg3: W) => R\n): (target: T, arg1: U, arg2: V, arg3: W) => R;\nexport function wrapNative<T, U, V, W, X, Y, R>(\n\tnativeFunction: (arg1: U, arg2: V, arg3: W, arg4: Y) => R\n): (target: T, arg1: U, arg2: V, arg3: W, arg4: Y) => R;\nexport function wrapNative(nativeFunction: (...args: any[]) => any): (target: any, ...args: any[]) => any {\n\treturn function(target: any, ...args: any[]): any {\n\t\treturn nativeFunction.apply(target, args);\n\t};\n}\n"]}