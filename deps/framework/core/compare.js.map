{"version":3,"file":"compare.js","sourceRoot":"","sources":["../../../../src/core/compare.ts"],"names":[],"mappings":"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","sourcesContent":["import { assign } from '../shim/object';\nimport { keys } from '../shim/object';\nimport Set from '../shim/Set';\n\n/* Assigning to local variables to improve minification and readability */\n\nconst objectCreate = Object.create;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst defineProperty = Object.defineProperty;\nconst isArray = Array.isArray;\nconst isFrozen = Object.isFrozen;\nconst isSealed = Object.isSealed;\n\nexport type IgnorePropertyFunction = (name: string, a: any, b: any) => boolean;\n\nexport interface DiffOptions {\n\t/**\n\t * Allow functions to be values.  Values will be considered equal if the `typeof` both values are `function`.\n\t * When adding or updating the property, the value of the property of `a` will be used in the record, which\n\t * will be a reference to the function.\n\t */\n\tallowFunctionValues?: boolean;\n\n\t/**\n\t * An array of strings or regular expressions which flag certain properties to be ignored.  Alternatively\n\t * a function, which returns `true` to have the property ignored or `false` to diff the property.\n\t */\n\tignoreProperties?: (string | RegExp)[] | IgnorePropertyFunction;\n\n\t/**\n\t * An array of strings or regular expressions which flag certain values to be ignored.  For flagged properties,\n\t * if the property is present in both `a` and `b` the value will be ignored.  If adding the property,\n\t * whatever the value of the property of `a` will be used, which could be a reference.\n\t */\n\tignorePropertyValues?: (string | RegExp)[] | IgnorePropertyFunction;\n}\n\n/**\n * Interface for a generic constructor function\n */\nexport interface Constructor {\n\tnew (...args: any[]): object;\n\tprototype: object;\n}\n\n/**\n * A partial property descriptor that provides the property descriptor flags supported by the\n * complex property construction of `patch()`\n *\n * All properties are value properties, with the value being supplied by the `ConstructRecord`\n */\nexport interface ConstructDescriptor {\n\t/**\n\t * Is the property configurable?\n\t */\n\tconfigurable?: boolean;\n\n\t/**\n\t * Is the property enumerable?\n\t */\n\tenumerable?: boolean;\n\n\t/**\n\t * Is the property configurable?\n\t */\n\twritable?: boolean;\n}\n\n/**\n * A record that describes a constructor function and arguments necessary to create an instance of\n * an object\n */\nexport interface AnonymousConstructRecord {\n\t/**\n\t * Any arguments to pass to the constructor function\n\t */\n\targs?: any[];\n\n\t/**\n\t * The constructor function to use to create the instance\n\t */\n\tCtor: Constructor;\n\n\t/**\n\t * The partial descriptor that is used to set the value of the instance\n\t */\n\tdescriptor?: ConstructDescriptor;\n\n\t/**\n\t * Any patches to properties that need to occur on the instance\n\t */\n\tpropertyRecords?: (ConstructRecord | PatchRecord)[];\n}\n\nexport interface ConstructRecord extends AnonymousConstructRecord {\n\t/**\n\t * The name of the property on the Object\n\t */\n\tname: string;\n}\n\n/**\n * A record that describes the mutations necessary to a property of an object to make that property look\n * like another\n */\nexport type PatchRecord =\n\t| {\n\t\t\t/**\n\t\t\t * The name of the property on the Object\n\t\t\t */\n\t\t\tname: string;\n\n\t\t\t/**\n\t\t\t * The type of the patch\n\t\t\t */\n\t\t\ttype: 'delete';\n\t\t}\n\t| {\n\t\t\t/**\n\t\t\t * A property descriptor that describes the property in `name`\n\t\t\t */\n\t\t\tdescriptor: PropertyDescriptor;\n\n\t\t\t/**\n\t\t\t * The name of the property on the Object\n\t\t\t */\n\t\t\tname: string;\n\n\t\t\t/**\n\t\t\t * The type of the patch\n\t\t\t */\n\t\t\ttype: 'add' | 'update';\n\n\t\t\t/**\n\t\t\t * Additional patch records which describe the value of the property\n\t\t\t */\n\t\t\tvalueRecords?: (ConstructRecord | PatchRecord | SpliceRecord)[];\n\t\t};\n\n/**\n * The different types of patch records supported\n */\nexport type PatchTypes = 'add' | 'update' | 'delete';\n\n/**\n * A record that describes a splice operation to perform on an array to make the array look like another array\n */\nexport interface SpliceRecord {\n\t/**\n\t * Any items that are being added to the array\n\t */\n\tadd?: any[];\n\n\t/**\n\t * The number of items in the array to delete\n\t */\n\tdeleteCount: number;\n\n\t/**\n\t * The type, set to `splice`\n\t */\n\ttype: 'splice';\n\n\t/**\n\t * The index of where to start the splice\n\t */\n\tstart: number;\n}\n\n/**\n * A record that describes how to instantiate a new object via a constructor function\n * @param Ctor The constructor function\n * @param args Any arguments to be passed to the constructor function\n */\n/* tslint:disable:variable-name */\nexport function createConstructRecord(\n\tCtor: Constructor,\n\targs?: any[],\n\tdescriptor?: ConstructDescriptor\n): AnonymousConstructRecord {\n\tconst record: AnonymousConstructRecord = assign(objectCreate(null), { Ctor });\n\tif (args) {\n\t\trecord.args = args;\n\t}\n\tif (descriptor) {\n\t\trecord.descriptor = descriptor;\n\t}\n\treturn record;\n}\n/* tslint:enable:variable-name */\n\n/**\n * An internal function that returns a new patch record\n *\n * @param type The type of patch record\n * @param name The property name the record refers to\n * @param descriptor The property descriptor to be installed on the object\n * @param valueRecords Any subsequenet patch recrds to be applied to the value of the descriptor\n */\nfunction createPatchRecord(\n\ttype: PatchTypes,\n\tname: string,\n\tdescriptor?: PropertyDescriptor,\n\tvalueRecords?: (ConstructRecord | PatchRecord | SpliceRecord)[]\n): PatchRecord {\n\tconst patchRecord = assign(objectCreate(null), {\n\t\ttype,\n\t\tname\n\t});\n\n\tif (descriptor) {\n\t\tpatchRecord.descriptor = descriptor;\n\t}\n\tif (valueRecords) {\n\t\tpatchRecord.valueRecords = valueRecords;\n\t}\n\n\treturn patchRecord as PatchRecord;\n}\n\n/**\n * An internal function that returns a new splice record\n *\n * @param start Where in the array to start the splice\n * @param deleteCount The number of elements to delete from the array\n * @param add Elements to be added to the target\n */\nfunction createSpliceRecord(start: number, deleteCount: number, add?: any[]): SpliceRecord {\n\tconst spliceRecord: SpliceRecord = assign(objectCreate(null), {\n\t\ttype: 'splice',\n\t\tstart,\n\t\tdeleteCount\n\t});\n\n\tif (add && add.length) {\n\t\tspliceRecord.add = add;\n\t}\n\n\treturn spliceRecord;\n}\n\n/**\n * A function that produces a value property descriptor, which assumes that properties are enumerable, writable and configurable\n * unless specified\n *\n * @param value The value for the descriptor\n * @param writable Defaults to `true` if not specified\n * @param enumerable Defaults to `true` if not specified\n * @param configurable Defaults to `true` if not specified\n */\nfunction createValuePropertyDescriptor(\n\tvalue: any,\n\twritable: boolean = true,\n\tenumerable: boolean = true,\n\tconfigurable: boolean = true\n): PropertyDescriptor {\n\treturn assign(objectCreate(null), {\n\t\tvalue,\n\t\twritable,\n\t\tenumerable,\n\t\tconfigurable\n\t});\n}\n\n/**\n * A function that returns a constructor record or `undefined` when diffing a value\n */\nexport type CustomDiffFunction<T> = (\n\tvalue: T,\n\tnameOrIndex: string | number,\n\tparent: object\n) => AnonymousConstructRecord | void;\n\n/**\n * A class which is used when making a custom comparison of a non-plain object or array\n */\nexport class CustomDiff<T> {\n\tprivate _differ: CustomDiffFunction<T>;\n\n\tconstructor(diff: CustomDiffFunction<T>) {\n\t\tthis._differ = diff;\n\t}\n\n\t/**\n\t * Get the difference of the `value`\n\t * @param value The value to diff\n\t * @param nameOrIndex A `string` if comparing a property or a `number` if comparing an array element\n\t * @param parent The outer parent that this value is part of\n\t */\n\tdiff(value: T, nameOrIndex: string | number, parent: object): ConstructRecord | void {\n\t\tconst record = this._differ(value, nameOrIndex, parent);\n\t\tif (record && typeof nameOrIndex === 'string') {\n\t\t\treturn assign(record, { name: nameOrIndex });\n\t\t}\n\t}\n}\n\n/**\n * Internal function that detects the differences between an array and another value and returns a set of splice records that\n * describe the differences\n *\n * @param a The first array to compare to\n * @param b The second value to compare to\n * @param options An options bag that allows configuration of the behaviour of `diffArray()`\n */\nfunction diffArray(a: any[], b: any, options: DiffOptions): SpliceRecord[] {\n\t/* This function takes an overly simplistic approach to calculating splice records.  There are many situations where\n\t * in complicated array mutations, the splice records can be more optimised.\n\t *\n\t * TODO: Raise an issue for this when it is finally merged and put into core\n\t */\n\n\tconst { allowFunctionValues = false } = options;\n\n\tconst arrayA = a;\n\tconst lengthA = arrayA.length;\n\tconst arrayB = isArray(b) ? b : [];\n\tconst lengthB = arrayB.length;\n\tconst patchRecords: SpliceRecord[] = [];\n\n\tif (!lengthA && lengthB) {\n\t\t/* empty array */\n\t\tpatchRecords.push(createSpliceRecord(0, lengthB));\n\t\treturn patchRecords;\n\t}\n\n\tlet add: any[] = [];\n\tlet start = 0;\n\tlet deleteCount = 0;\n\tlet last = -1;\n\n\tfunction flushSpliceRecord() {\n\t\tif (deleteCount || add.length) {\n\t\t\tpatchRecords.push(\n\t\t\t\tcreateSpliceRecord(start, start + deleteCount > lengthB ? lengthB - start : deleteCount, add)\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction addDifference(index: number, adding: boolean, value?: any) {\n\t\tif (index > last + 1) {\n\t\t\t/* flush the splice */\n\t\t\tflushSpliceRecord();\n\t\t\tstart = index;\n\t\t\tdeleteCount = 0;\n\t\t\tif (add.length) {\n\t\t\t\tadd = [];\n\t\t\t}\n\t\t}\n\n\t\tif (adding) {\n\t\t\tadd.push(value);\n\t\t}\n\t\tdeleteCount++;\n\t\tlast = index;\n\t}\n\n\tarrayA.forEach((valueA, index) => {\n\t\tconst valueB = arrayB[index];\n\n\t\tif (\n\t\t\tindex in arrayB &&\n\t\t\t(valueA === valueB || (allowFunctionValues && typeof valueA === 'function' && typeof valueB === 'function'))\n\t\t) {\n\t\t\treturn; /* not different */\n\t\t}\n\n\t\tconst isValueAArray = isArray(valueA);\n\t\tconst isValueAPlainObject = isPlainObject(valueA);\n\n\t\tif (isValueAArray || isValueAPlainObject) {\n\t\t\tconst value = isValueAArray\n\t\t\t\t? isArray(valueB) ? valueB : []\n\t\t\t\t: isPlainObject(valueB) ? valueB : Object.create(null);\n\t\t\tconst valueRecords = diff(valueA, value, options);\n\t\t\tif (valueRecords.length) {\n\t\t\t\t/* only add if there are changes */\n\t\t\t\taddDifference(index, true, diff(valueA, value, options));\n\t\t\t}\n\t\t} else if (isPrimitive(valueA)) {\n\t\t\taddDifference(index, true, valueA);\n\t\t} else if (allowFunctionValues && typeof valueA === 'function') {\n\t\t\taddDifference(index, true, valueA);\n\t\t} else {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Value of array element \"${index}\" from first argument is not a primative, plain Object, or Array.`\n\t\t\t);\n\t\t}\n\t});\n\n\tif (lengthB > lengthA) {\n\t\tfor (let index = lengthA; index < lengthB; index++) {\n\t\t\taddDifference(index, false);\n\t\t}\n\t}\n\n\t/* flush any deletes */\n\tflushSpliceRecord();\n\n\treturn patchRecords;\n}\n\n/**\n * Internal function that detects the differences between plain objects and returns a set of patch records that\n * describe the differences\n *\n * @param a The first plain object to compare to\n * @param b The second plain bject to compare to\n * @param options An options bag that allows configuration of the behaviour of `diffPlainObject()`\n */\nfunction diffPlainObject(a: any, b: any, options: DiffOptions): (ConstructRecord | PatchRecord)[] {\n\tconst { allowFunctionValues = false, ignorePropertyValues = [] } = options;\n\tconst patchRecords: (ConstructRecord | PatchRecord)[] = [];\n\tconst { comparableA, comparableB } = getComparableObjects(a, b, options);\n\n\t/* look for keys in a that are different from b */\n\tkeys(comparableA).reduce((patchRecords, name) => {\n\t\tconst valueA = a[name];\n\t\tconst valueB = b[name];\n\t\tconst bHasOwnProperty = hasOwnProperty.call(comparableB, name);\n\n\t\tif (\n\t\t\tbHasOwnProperty &&\n\t\t\t(valueA === valueB || (allowFunctionValues && typeof valueA === 'function' && typeof valueB === 'function'))\n\t\t) {\n\t\t\t/* not different */\n\t\t\t/* when `allowFunctionValues` is true, functions are simply considered to be equal by `typeof` */\n\t\t\treturn patchRecords;\n\t\t}\n\n\t\tconst type = bHasOwnProperty ? 'update' : 'add';\n\n\t\tconst isValueAArray = isArray(valueA);\n\t\tconst isValueAPlainObject = isPlainObject(valueA);\n\n\t\tif (isValueAArray || isValueAPlainObject) {\n\t\t\t/* non-primitive values we can diff */\n\t\t\t/* this is a bit complicated, but essentially if valueA and valueB are both arrays or plain objects, then\n\t\t\t* we can diff those two values, if not, then we need to use an empty array or an empty object and diff\n\t\t\t* the valueA with that */\n\t\t\tconst value =\n\t\t\t\t(isValueAArray && isArray(valueB)) || (isValueAPlainObject && isPlainObject(valueB))\n\t\t\t\t\t? valueB\n\t\t\t\t\t: isValueAArray ? [] : objectCreate(null);\n\t\t\tconst valueRecords = diff(valueA, value, options);\n\t\t\tif (valueRecords.length) {\n\t\t\t\t/* only add if there are changes */\n\t\t\t\tpatchRecords.push(\n\t\t\t\t\tcreatePatchRecord(type, name, createValuePropertyDescriptor(value), diff(valueA, value, options))\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (isCustomDiff(valueA) && !isCustomDiff(valueB)) {\n\t\t\t/* complex diff left hand */\n\t\t\tconst result = valueA.diff(valueB, name, b);\n\t\t\tif (result) {\n\t\t\t\tpatchRecords.push(result);\n\t\t\t}\n\t\t} else if (isCustomDiff(valueB)) {\n\t\t\t/* complex diff right hand */\n\t\t\tconst result = valueB.diff(valueA, name, a);\n\t\t\tif (result) {\n\t\t\t\tpatchRecords.push(result);\n\t\t\t}\n\t\t} else if (\n\t\t\tisPrimitive(valueA) ||\n\t\t\t(allowFunctionValues && typeof valueA === 'function') ||\n\t\t\tisIgnoredPropertyValue(name, a, b, ignorePropertyValues)\n\t\t) {\n\t\t\t/* primitive values, functions values if allowed, or ignored property values can just be copied */\n\t\t\tpatchRecords.push(createPatchRecord(type, name, createValuePropertyDescriptor(valueA)));\n\t\t} else {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Value of property named \"${name}\" from first argument is not a primative, plain Object, or Array.`\n\t\t\t);\n\t\t}\n\t\treturn patchRecords;\n\t}, patchRecords);\n\n\t/* look for keys in b that are not in a */\n\tkeys(comparableB).reduce((patchRecords, name) => {\n\t\tif (!hasOwnProperty.call(comparableA, name)) {\n\t\t\tpatchRecords.push(createPatchRecord('delete', name));\n\t\t}\n\t\treturn patchRecords;\n\t}, patchRecords);\n\n\treturn patchRecords;\n}\n\n/**\n * Takes two plain objects to be compared, as well as options customizing the behavior of the comparison, and returns\n * two new objects that contain only those properties that should be compared. If a property is ignored\n * it will not be included in either returned object. If a property's value should be ignored it will be excluded\n * if it is present in both objects.\n * @param a The first object to compare\n * @param b The second object to compare\n * @param options An options bag indicating which properties should be ignored or have their values ignored, if any.\n */\nexport function getComparableObjects(a: any, b: any, options: DiffOptions) {\n\tconst { ignoreProperties = [], ignorePropertyValues = [] } = options;\n\tconst ignore = new Set<string>();\n\tconst keep = new Set<string>();\n\n\tconst isIgnoredProperty = Array.isArray(ignoreProperties)\n\t\t? (name: string) => {\n\t\t\t\treturn ignoreProperties.some(\n\t\t\t\t\t(value) => (typeof value === 'string' ? name === value : value.test(name))\n\t\t\t\t);\n\t\t\t}\n\t\t: (name: string) => ignoreProperties(name, a, b);\n\n\tconst comparableA = keys(a).reduce(\n\t\t(obj, name) => {\n\t\t\tif (\n\t\t\t\tisIgnoredProperty(name) ||\n\t\t\t\t(hasOwnProperty.call(b, name) && isIgnoredPropertyValue(name, a, b, ignorePropertyValues))\n\t\t\t) {\n\t\t\t\tignore.add(name);\n\t\t\t\treturn obj;\n\t\t\t}\n\n\t\t\tkeep.add(name);\n\t\t\tobj[name] = a[name];\n\t\t\treturn obj;\n\t\t},\n\t\t{} as { [key: string]: any }\n\t);\n\n\tconst comparableB = keys(b).reduce(\n\t\t(obj, name) => {\n\t\t\tif (ignore.has(name) || (!keep.has(name) && isIgnoredProperty(name))) {\n\t\t\t\treturn obj;\n\t\t\t}\n\n\t\t\tobj[name] = b[name];\n\t\t\treturn obj;\n\t\t},\n\t\t{} as { [key: string]: any }\n\t);\n\n\treturn { comparableA, comparableB, ignore };\n}\n\n/**\n * A guard that determines if the value is a `ConstructRecord`\n * @param value The value to check\n */\nfunction isConstructRecord(value: any): value is ConstructRecord {\n\treturn Boolean(value && typeof value === 'object' && value !== null && value.Ctor && value.name);\n}\n\nfunction isIgnoredPropertyValue(\n\tname: string,\n\ta: any,\n\tb: any,\n\tignoredPropertyValues: (string | RegExp)[] | IgnorePropertyFunction\n) {\n\treturn Array.isArray(ignoredPropertyValues)\n\t\t? ignoredPropertyValues.some((value) => {\n\t\t\t\treturn typeof value === 'string' ? name === value : value.test(name);\n\t\t\t})\n\t\t: ignoredPropertyValues(name, a, b);\n}\n\n/**\n * A guard that determines if the value is a `PatchRecord`\n *\n * @param value The value to check\n */\nfunction isPatchRecord(value: any): value is PatchRecord {\n\treturn Boolean(value && value.type && value.name);\n}\n\n/**\n * A guard that determines if the value is an array of `PatchRecord`s\n *\n * @param value The value to check\n */\nfunction isPatchRecordArray(value: any): value is PatchRecord[] {\n\treturn Boolean(isArray(value) && value.length && isPatchRecord(value[0]));\n}\n\n/**\n * A guard that determines if the value is a plain object.  A plain object is an object that has\n * either no constructor (e.g. `Object.create(null)`) or has Object as its constructor.\n *\n * @param value The value to check\n */\nfunction isPlainObject(value: any): value is Object {\n\treturn Boolean(\n\t\tvalue && typeof value === 'object' && (value.constructor === Object || value.constructor === undefined)\n\t);\n}\n\n/**\n * A guard that determines if the value is a primitive (including `null`), as these values are\n * fine to just copy.\n *\n * @param value The value to check\n */\nfunction isPrimitive(value: any): value is string | number | boolean | undefined | null {\n\tconst typeofValue = typeof value;\n\treturn (\n\t\tvalue === null ||\n\t\ttypeofValue === 'undefined' ||\n\t\ttypeofValue === 'string' ||\n\t\ttypeofValue === 'number' ||\n\t\ttypeofValue === 'boolean'\n\t);\n}\n\n/**\n * A guard that determines if the value is a `CustomDiff`\n * @param value The value to check\n */\nfunction isCustomDiff<T>(value: any): value is CustomDiff<T> {\n\treturn typeof value === 'object' && value instanceof CustomDiff;\n}\n\n/**\n * A guard that determines if the value is a `SpliceRecord`\n *\n * @param value The value to check\n */\nfunction isSpliceRecord(value: any): value is SpliceRecord {\n\treturn value && value.type === 'splice' && 'start' in value && 'deleteCount' in value;\n}\n\n/**\n * A guard that determines if the value is an array of `SpliceRecord`s\n *\n * @param value The value to check\n */\nfunction isSpliceRecordArray(value: any): value is SpliceRecord[] {\n\treturn Boolean(isArray(value) && value.length && isSpliceRecord(value[0]));\n}\n\n/**\n * An internal function that patches a target with a `SpliceRecord`\n */\nfunction patchSplice(target: any[], { add, deleteCount, start }: SpliceRecord): any {\n\tif (add && add.length) {\n\t\tconst deletedItems = deleteCount ? target.slice(start, start + deleteCount) : [];\n\t\tadd = add.map((value, index) => resolveTargetValue(value, deletedItems[index]));\n\t\ttarget.splice(start, deleteCount, ...add);\n\t} else {\n\t\ttarget.splice(start, deleteCount);\n\t}\n\treturn target;\n}\n\n/**\n * An internal function that patches a target with a `PatchRecord`\n */\nfunction patchPatch(target: any, record: PatchRecord): any {\n\tconst { name } = record;\n\tif (record.type === 'delete') {\n\t\tdelete target[name];\n\t\treturn target;\n\t}\n\tconst { descriptor, valueRecords } = record;\n\tif (valueRecords && valueRecords.length) {\n\t\tdescriptor.value = patch(descriptor.value, valueRecords);\n\t}\n\tdefineProperty(target, name, descriptor);\n\treturn target;\n}\n\nconst defaultConstructDescriptor = {\n\tconfigurable: true,\n\tenumerable: true,\n\twritable: true\n};\n\nfunction patchConstruct(target: any, record: ConstructRecord): any {\n\tconst { args, descriptor = defaultConstructDescriptor, Ctor, name, propertyRecords } = record;\n\tconst value = new Ctor(...(args || []));\n\tif (propertyRecords) {\n\t\tpropertyRecords.forEach(\n\t\t\t(record) => (isConstructRecord(record) ? patchConstruct(value, record) : patchPatch(value, record))\n\t\t);\n\t}\n\tdefineProperty(target, name, assign({ value }, descriptor));\n\treturn target;\n}\n\n/**\n * An internal function that takes a value from array being patched and the target value from the same\n * index and determines the value that should actually be patched into the target array\n */\nfunction resolveTargetValue(patchValue: any, targetValue: any): any {\n\tconst patchIsSpliceRecordArray = isSpliceRecordArray(patchValue);\n\treturn patchIsSpliceRecordArray || isPatchRecordArray(patchValue)\n\t\t? patch(\n\t\t\t\tpatchIsSpliceRecordArray\n\t\t\t\t\t? isArray(targetValue) ? targetValue : []\n\t\t\t\t\t: isPlainObject(targetValue) ? targetValue : objectCreate(null),\n\t\t\t\tpatchValue\n\t\t\t)\n\t\t: patchValue;\n}\n\n/**\n * Compares two plain objects or arrays and return a set of records which describe the differences between the two\n *\n * The records describe what would need to be applied to the second argument to make it look like the first argument\n *\n * @param a The plain object or array to compare with\n * @param b The plain object or array to compare to\n * @param options An options bag that allows configuration of the behaviour of `diff()`\n */\nexport function diff(a: any, b: any, options: DiffOptions = {}): (ConstructRecord | PatchRecord | SpliceRecord)[] {\n\tif (typeof a !== 'object' || typeof b !== 'object') {\n\t\tthrow new TypeError('Arguments are not of type object.');\n\t}\n\n\tif (isArray(a)) {\n\t\treturn diffArray(a, b, options);\n\t}\n\n\tif (isArray(b)) {\n\t\tb = objectCreate(null);\n\t}\n\n\tif (!isPlainObject(a) || !isPlainObject(b)) {\n\t\tthrow new TypeError('Arguments are not plain Objects or Arrays.');\n\t}\n\n\treturn diffPlainObject(a, b, options);\n}\n\n/**\n * Apply a set of patch records to a target.\n *\n * @param target The plain object or array that the patch records should be applied to\n * @param records A set of patch records to be applied to the target\n */\nexport function patch(target: any, records: (ConstructRecord | PatchRecord | SpliceRecord)[]): any {\n\tif (!isArray(target) && !isPlainObject(target)) {\n\t\tthrow new TypeError('A target for a patch must be either an array or a plain object.');\n\t}\n\tif (isFrozen(target) || isSealed(target)) {\n\t\tthrow new TypeError('Cannot patch sealed or frozen objects.');\n\t}\n\n\trecords.forEach((record) => {\n\t\ttarget = isSpliceRecord(record)\n\t\t\t? patchSplice(isArray(target) ? target : [], record) /* patch arrays */\n\t\t\t: isConstructRecord(record)\n\t\t\t\t? patchConstruct(target, record) /* patch complex object */\n\t\t\t\t: patchPatch(isPlainObject(target) ? target : {}, record); /* patch plain object */\n\t});\n\treturn target;\n}\n"]}