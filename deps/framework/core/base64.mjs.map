{"version":3,"file":"base64.mjs","sourceRoot":"","sources":["base64.ts"],"names":[],"mappings":"AAAA,OAAO,MAAM,MAAM,gBAAgB,CAAC;AACpC,OAAO,GAAG,EAAE,EAAE,GAAG,IAAI,MAAM,EAAE,MAAM,YAAY,CAAC;AAEhD,MAAM,CAAC,MAAM,EAAE,MAAM,IAAI,MAAM,EAAE,IAAI,CAAC,CAAC;AACvC,MAAM,CAAC,MAAM,EAAE,MAAM,IAAI,MAAM,EAAE,IAAI,CAAC,CAAC;AAEvC;;;GAGG;AACH,MAAM,CAAC,MAAM,MAAM,GAAsC,GAAG,CAAC,MAAM,CAAC;IACnE,CAAC,CAAC,UAAS,aAAqB;QAC9B,4DAA4D;QAC5D,MAAM,CAAC,kBAAkB,CACxB,KAAK,CAAC,SAAS,CAAC,GAAG;aACjB,IAAI,CACJ,IAAI,CAAC,aAAa,CAAC,EACnB,CAAC,IAAY,EAAE,EAAE,CAAC,GAAG,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAC1E;aACA,IAAI,CAAC,EAAE,CAAC,CACV,CAAC;IACH,CAAC;IACF,CAAC,CAAC,UAAS,aAAqB;QAC9B,MAAM,CAAC,IAAI,MAAM,CAAC,aAAa,CAAC,QAAQ,EAAE,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;IACxE,CAAC,CAAC;AAEJ;;;GAGG;AACH,MAAM,CAAC,MAAM,MAAM,GAAkC,GAAG,CAAC,MAAM,CAAC;IAC/D,CAAC,CAAC,UAAS,aAAqB;QAC9B,4DAA4D;QAC5D,MAAM,CAAC,IAAI,CACV,kBAAkB,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,iBAAiB,EAAE,CAAC,KAAK,EAAE,IAAY,EAAE,EAAE,CACpF,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,CACxC,CACD,CAAC;IACH,CAAC;IACF,CAAC,CAAC,UAAS,SAAiB;QAC1B,MAAM,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,QAAQ,EAAE,EAAE,MAAM,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;IACpE,CAAC,CAAC","sourcesContent":["import global from '../shim/global';\nimport has, { add as hasAdd } from '../has/has';\n\nhasAdd('btoa', 'btoa' in global, true);\nhasAdd('atob', 'atob' in global, true);\n\n/**\n * Take a string encoded in base64 and decode it\n * @param encodedString The base64 encoded string\n */\nexport const decode: (encodedString: string) => string = has('atob')\n\t? function(encodedString: string) {\n\t\t\t/* this allows for utf8 characters to be decoded properly */\n\t\t\treturn decodeURIComponent(\n\t\t\t\tArray.prototype.map\n\t\t\t\t\t.call(\n\t\t\t\t\t\tatob(encodedString),\n\t\t\t\t\t\t(char: string) => '%' + ('00' + char.charCodeAt(0).toString(16)).slice(-2)\n\t\t\t\t\t)\n\t\t\t\t\t.join('')\n\t\t\t);\n\t\t}\n\t: function(encodedString: string): string {\n\t\t\treturn new Buffer(encodedString.toString(), 'base64').toString('utf8');\n\t\t};\n\n/**\n * Take a string and encode it to base64\n * @param rawString The string to encode\n */\nexport const encode: (rawString: string) => string = has('btoa')\n\t? function(decodedString: string) {\n\t\t\t/* this allows for utf8 characters to be encoded properly */\n\t\t\treturn btoa(\n\t\t\t\tencodeURIComponent(decodedString).replace(/%([0-9A-F]{2})/g, (match, code: string) =>\n\t\t\t\t\tString.fromCharCode(Number('0x' + code))\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t: function(rawString: string): string {\n\t\t\treturn new Buffer(rawString.toString(), 'utf8').toString('base64');\n\t\t};\n"]}