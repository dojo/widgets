{"version":3,"file":"interfaces.js","sourceRoot":"","sources":["interfaces.ts"],"names":[],"mappings":"","sourcesContent":["export type EventType = string | symbol;\n\n/**\n * The base event object, which provides a `type` property\n */\nexport interface EventObject<T = EventType> {\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: T;\n}\n\nexport interface EventErrorObject<T = EventType> extends EventObject<T> {\n\t/**\n\t * The error that is the subject of this event\n\t */\n\treadonly error: Error;\n}\n\n/**\n * An interface for an object which provides a cancelable event API.  By calling the\n * `.preventDefault()` method on the object, the event should be cancelled and not\n * proceed any further\n */\nexport interface EventCancelableObject<T = EventType> extends EventObject<T> {\n\t/**\n\t * Can the event be canceled?\n\t */\n\treadonly cancelable: boolean;\n\n\t/**\n\t * Was the event canceled?\n\t */\n\treadonly defaultPrevented: boolean;\n\n\t/**\n\t * Cancel the event\n\t */\n\tpreventDefault(): void;\n}\n\n/**\n * Used through the toolkit as a consistent API to manage how callers can \"cleanup\"\n * when doing a function.\n */\nexport interface Handle {\n\t/**\n\t * Perform the destruction/cleanup logic associated with this handle\n\t */\n\tdestroy(): void;\n}\n\n/**\n * A general interface that can be used to renference a general index map of values of a particular type\n */\nexport interface Hash<T> {\n\t[id: string]: T;\n}\n\n/**\n * A base map of styles where each key is the name of the style attribute and the value is a string\n * which represents the style\n */\nexport interface StylesMap {\n\t[style: string]: string;\n}\n\n/**\n * The interfaces to the `@dojo/loader` AMD loader\n */\n\nexport interface AmdConfig {\n\t/**\n\t * The base URL that the loader will use to resolve modules\n\t */\n\tbaseUrl?: string;\n\n\t/**\n\t * A map of module identifiers and their replacement meta data\n\t */\n\tmap?: AmdModuleMap;\n\n\t/**\n\t * An array of packages that the loader should use when resolving a module ID\n\t */\n\tpackages?: AmdPackage[];\n\n\t/**\n\t * A map of paths to use when resolving modules names\n\t */\n\tpaths?: { [path: string]: string };\n\n\t/**\n\t * A map of packages that the loader should use when resolving a module ID\n\t */\n\tpkgs?: { [path: string]: AmdPackage };\n}\n\nexport interface AmdDefine {\n\t/**\n\t * Define a module\n\t *\n\t * @param moduleId the MID to use for the module\n\t * @param dependencies an array of MIDs this module depends upon\n\t * @param factory the factory function that will return the module\n\t */\n\t(moduleId: string, dependencies: string[], factory: AmdFactory): void;\n\n\t/**\n\t * Define a module\n\t *\n\t * @param dependencies an array of MIDs this module depends upon\n\t * @param factory the factory function that will return the module\n\t */\n\t(dependencies: string[], factory: AmdFactory): void;\n\n\t/**\n\t * Define a module\n\t *\n\t * @param factory the factory function that will return the module\n\t */\n\t(factory: AmdFactory): void;\n\n\t/**\n\t * Define a module\n\t *\n\t * @param value the value for the module\n\t */\n\t(value: any): void;\n\n\t/**\n\t * Meta data about this particular AMD loader\n\t */\n\tamd: { [prop: string]: string | number | boolean };\n}\n\nexport interface AmdFactory {\n\t/**\n\t * The module factory\n\t *\n\t * @param modules The arguments that represent the resolved versions of the module dependencies\n\t */\n\t(...modules: any[]): any;\n}\n\nexport interface AmdHas {\n\t/**\n\t * Determine if a feature is present\n\t *\n\t * @param name the feature name to check\n\t */\n\t(name: string): any;\n\n\t/**\n\t * Register a feature test\n\t *\n\t * @param name The name of the feature to register\n\t * @param value The test for the feature\n\t * @param now If `true` the test will be executed immediatly, if not, it will be lazily executed\n\t * @param force If `true` the test value will be overwritten if already registered\n\t */\n\tadd(\n\t\tname: string,\n\t\tvalue: (global: Window, document?: HTMLDocument, element?: HTMLDivElement) => any,\n\t\tnow?: boolean,\n\t\tforce?: boolean\n\t): void;\n\tadd(name: string, value: any, now?: boolean, force?: boolean): void;\n}\n\nexport interface AmdModuleMap extends AmdModuleMapItem {\n\t[sourceMid: string]: AmdModuleMapReplacement;\n}\n\nexport interface AmdModuleMapItem {\n\t[mid: string]: any;\n}\n\nexport interface AmdModuleMapReplacement extends AmdModuleMapItem {\n\t[findMid: string]: string;\n}\n\nexport interface NodeRequire {\n\t(moduleId: string): any;\n\tresolve(moduleId: string): string;\n}\n\nexport interface AmdPackage {\n\t/**\n\t * The path to the root of the package\n\t */\n\tlocation?: string;\n\n\t/**\n\t * The main module of the package (defaults to `main.js`)\n\t */\n\tmain?: string;\n\n\t/**\n\t * The package name\n\t */\n\tname?: string;\n}\n\nexport interface AmdRequire {\n\t/**\n\t * Resolve a list of module dependencies and pass them to the callback\n\t *\n\t * @param dependencies The array of MIDs to resolve\n\t * @param callback The function to invoke with the resolved dependencies\n\t */\n\t(dependencies: string[], callback: AmdRequireCallback): void;\n\n\t/**\n\t * Resolve and return a single module (compatability with CommonJS `require`)\n\t *\n\t * @param moduleId The module ID to resolve and return\n\t */\n\t<ModuleType>(moduleId: string): ModuleType;\n\n\t/**\n\t * If running in the node environment, a reference to the original NodeJS `require`\n\t */\n\tnodeRequire?: NodeRequire;\n\n\t/**\n\t * Take a relative MID and return an absolute MID\n\t *\n\t * @param moduleId The relative module ID to resolve\n\t */\n\ttoAbsMid(moduleId: string): string;\n\n\t/**\n\t * Take a path and resolve the full URL for the path\n\t *\n\t * @param path The path to resolve and return as a URL\n\t */\n\ttoUrl(path: string): string;\n}\n\nexport interface AmdRequireCallback {\n\t/**\n\t * The `require` callback\n\t *\n\t * @param modules The arguments that represent the resolved versions of dependencies\n\t */\n\t(...modules: any[]): void;\n}\n\nexport interface AmdRootRequire extends AmdRequire {\n\t/**\n\t * The minimalist `has` API integrated with the `@dojo/loader`\n\t */\n\thas: AmdHas;\n\n\t/**\n\t * Register an event listener\n\t *\n\t * @param type The event type to listen for\n\t * @param listener The listener to call when the event is emitted\n\t */\n\ton(type: AmdRequireOnSignalType, listener: any): { remove: () => void };\n\n\t/**\n\t * Configure the loader\n\t *\n\t * @param config The configuration to apply to the loader\n\t */\n\tconfig(config: AmdConfig): void;\n\n\t/**\n\t * Return internal values of loader for debug purposes\n\t *\n\t * @param name The name of the internal label\n\t */\n\tinspect?(name: string): any;\n\n\t/**\n\t * Undefine a module, based on absolute MID that should be removed from the loader cache\n\t */\n\tundef(moduleId: string): void;\n}\n\n/**\n * The signal type for the `require.on` API\n */\nexport type AmdRequireOnSignalType = 'error';\n"]}