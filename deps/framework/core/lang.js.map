{"version":3,"file":"lang.js","sourceRoot":"","sources":["../../../../src/core/lang.ts"],"names":[],"mappings":"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","sourcesContent":["import { Handle } from './interfaces';\nimport { assign } from '../shim/object';\n\nexport { assign } from '../shim/object';\n\nconst slice = Array.prototype.slice;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Type guard that ensures that the value can be coerced to Object\n * to weed out host objects that do not derive from Object.\n * This function is used to check if we want to deep copy an object or not.\n * Note: In ES6 it is possible to modify an object's Symbol.toStringTag property, which will\n * change the value returned by `toString`. This is a rare edge case that is difficult to handle,\n * so it is not handled here.\n * @param  value The value to check\n * @return       If the value is coercible into an Object\n */\nfunction shouldDeepCopyObject(value: any): value is Object {\n\treturn Object.prototype.toString.call(value) === '[object Object]';\n}\n\nfunction copyArray<T>(array: T[], inherited: boolean): T[] {\n\treturn array.map(function(item: T): T {\n\t\tif (Array.isArray(item)) {\n\t\t\treturn <any>copyArray(<any>item, inherited);\n\t\t}\n\n\t\treturn !shouldDeepCopyObject(item)\n\t\t\t? item\n\t\t\t: _mixin({\n\t\t\t\t\tdeep: true,\n\t\t\t\t\tinherited: inherited,\n\t\t\t\t\tsources: <Array<T>>[item],\n\t\t\t\t\ttarget: <T>{}\n\t\t\t\t});\n\t});\n}\n\ninterface MixinArgs<T extends {}, U extends {}> {\n\tdeep: boolean;\n\tinherited: boolean;\n\tsources: (U | null | undefined)[];\n\ttarget: T;\n\tcopied?: any[];\n}\n\nfunction _mixin<T extends {}, U extends {}>(kwArgs: MixinArgs<T, U>): T & U {\n\tconst deep = kwArgs.deep;\n\tconst inherited = kwArgs.inherited;\n\tconst target: any = kwArgs.target;\n\tconst copied = kwArgs.copied || [];\n\tconst copiedClone = [...copied];\n\n\tfor (let i = 0; i < kwArgs.sources.length; i++) {\n\t\tconst source = kwArgs.sources[i];\n\n\t\tif (source === null || source === undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (let key in source) {\n\t\t\tif (inherited || hasOwnProperty.call(source, key)) {\n\t\t\t\tlet value: any = source[key];\n\n\t\t\t\tif (copiedClone.indexOf(value) !== -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (deep) {\n\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\tvalue = copyArray(value, inherited);\n\t\t\t\t\t} else if (shouldDeepCopyObject(value)) {\n\t\t\t\t\t\tconst targetValue: any = target[key] || {};\n\t\t\t\t\t\tcopied.push(source);\n\t\t\t\t\t\tvalue = _mixin({\n\t\t\t\t\t\t\tdeep: true,\n\t\t\t\t\t\t\tinherited: inherited,\n\t\t\t\t\t\t\tsources: [value],\n\t\t\t\t\t\t\ttarget: targetValue,\n\t\t\t\t\t\t\tcopied\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttarget[key] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn <T & U>target;\n}\n\n/**\n * Creates a new object from the given prototype, and copies all enumerable own properties of one or more\n * source objects to the newly created target object.\n *\n * @param prototype The prototype to create a new object from\n * @param mixins Any number of objects whose enumerable own properties will be copied to the created object\n * @return The new object\n */\nexport function create<\n\tT extends {},\n\tU extends {},\n\tV extends {},\n\tW extends {},\n\tX extends {},\n\tY extends {},\n\tZ extends {}\n>(prototype: T, mixin1: U, mixin2: V, mixin3: W, mixin4: X, mixin5: Y, mixin6: Z): T & U & V & W & X & Y & Z;\nexport function create<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(\n\tprototype: T,\n\tmixin1: U,\n\tmixin2: V,\n\tmixin3: W,\n\tmixin4: X,\n\tmixin5: Y\n): T & U & V & W & X & Y;\nexport function create<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(\n\tprototype: T,\n\tmixin1: U,\n\tmixin2: V,\n\tmixin3: W,\n\tmixin4: X\n): T & U & V & W & X;\nexport function create<T extends {}, U extends {}, V extends {}, W extends {}>(\n\tprototype: T,\n\tmixin1: U,\n\tmixin2: V,\n\tmixin3: W\n): T & U & V & W;\nexport function create<T extends {}, U extends {}, V extends {}>(prototype: T, mixin1: U, mixin2: V): T & U & V;\nexport function create<T extends {}, U extends {}>(prototype: T, mixin: U): T & U;\nexport function create<T extends {}>(prototype: T): T;\nexport function create(prototype: any, ...mixins: any[]): any {\n\tif (!mixins.length) {\n\t\tthrow new RangeError('lang.create requires at least one mixin object.');\n\t}\n\n\tconst args = mixins.slice();\n\targs.unshift(Object.create(prototype));\n\n\treturn assign.apply(null, args);\n}\n\n/**\n * Copies the values of all enumerable own properties of one or more source objects to the target object,\n * recursively copying all nested objects and arrays as well.\n *\n * @param target The target object to receive values from source objects\n * @param sources Any number of objects whose enumerable own properties will be copied to the target object\n * @return The modified target object\n */\nexport function deepAssign<\n\tT extends {},\n\tU extends {},\n\tV extends {},\n\tW extends {},\n\tX extends {},\n\tY extends {},\n\tZ extends {}\n>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y, source6: Z): T & U & V & W & X & Y & Z;\nexport function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W,\n\tsource4: X,\n\tsource5: Y\n): T & U & V & W & X & Y;\nexport function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W,\n\tsource4: X\n): T & U & V & W & X;\nexport function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W\n): T & U & V & W;\nexport function deepAssign<T extends {}, U extends {}, V extends {}>(target: T, source1: U, source2: V): T & U & V;\nexport function deepAssign<T extends {}, U extends {}>(target: T, source: U): T & U;\nexport function deepAssign(target: any, ...sources: any[]): any {\n\treturn _mixin({\n\t\tdeep: true,\n\t\tinherited: false,\n\t\tsources: sources,\n\t\ttarget: target\n\t});\n}\n\n/**\n * Copies the values of all enumerable (own or inherited) properties of one or more source objects to the\n * target object, recursively copying all nested objects and arrays as well.\n *\n * @param target The target object to receive values from source objects\n * @param sources Any number of objects whose enumerable properties will be copied to the target object\n * @return The modified target object\n */\nexport function deepMixin<\n\tT extends {},\n\tU extends {},\n\tV extends {},\n\tW extends {},\n\tX extends {},\n\tY extends {},\n\tZ extends {}\n>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y, source6: Z): T & U & V & W & X & Y & Z;\nexport function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W,\n\tsource4: X,\n\tsource5: Y\n): T & U & V & W & X & Y;\nexport function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W,\n\tsource4: X\n): T & U & V & W & X;\nexport function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W\n): T & U & V & W;\nexport function deepMixin<T extends {}, U extends {}, V extends {}>(target: T, source1: U, source2: V): T & U & V;\nexport function deepMixin<T extends {}, U extends {}>(target: T, source: U): T & U;\nexport function deepMixin(target: any, ...sources: any[]): any {\n\treturn _mixin({\n\t\tdeep: true,\n\t\tinherited: true,\n\t\tsources: sources,\n\t\ttarget: target\n\t});\n}\n\n/**\n * Creates a new object using the provided source's prototype as the prototype for the new object, and then\n * deep copies the provided source's values into the new target.\n *\n * @param source The object to duplicate\n * @return The new object\n */\nexport function duplicate<T extends {}>(source: T): T {\n\tconst target = Object.create(Object.getPrototypeOf(source));\n\n\treturn deepMixin(target, source);\n}\n\n/**\n * Determines whether two values are the same value.\n *\n * @param a First value to compare\n * @param b Second value to compare\n * @return true if the values are the same; false otherwise\n */\nexport function isIdentical(a: any, b: any): boolean {\n\treturn (\n\t\ta === b ||\n\t\t/* both values are NaN */\n\t\t(a !== a && b !== b)\n\t);\n}\n\n/**\n * Returns a function that binds a method to the specified object at runtime. This is similar to\n * `Function.prototype.bind`, but instead of a function it takes the name of a method on an object.\n * As a result, the function returned by `lateBind` will always call the function currently assigned to\n * the specified property on the object as of the moment the function it returns is called.\n *\n * @param instance The context object\n * @param method The name of the method on the context object to bind to itself\n * @param suppliedArgs An optional array of values to prepend to the `instance[method]` arguments list\n * @return The bound function\n */\nexport function lateBind(instance: {}, method: string, ...suppliedArgs: any[]): (...args: any[]) => any {\n\treturn suppliedArgs.length\n\t\t? function() {\n\t\t\t\tconst args: any[] = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n\n\t\t\t\t// TS7017\n\t\t\t\treturn (<any>instance)[method].apply(instance, args);\n\t\t\t}\n\t\t: function() {\n\t\t\t\t// TS7017\n\t\t\t\treturn (<any>instance)[method].apply(instance, arguments);\n\t\t\t};\n}\n\n/**\n * Copies the values of all enumerable (own or inherited) properties of one or more source objects to the\n * target object.\n *\n * @return The modified target object\n */\nexport function mixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}, Z extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W,\n\tsource4: X,\n\tsource5: Y,\n\tsource6: Z\n): T & U & V & W & X & Y & Z;\nexport function mixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W,\n\tsource4: X,\n\tsource5: Y\n): T & U & V & W & X & Y;\nexport function mixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W,\n\tsource4: X\n): T & U & V & W & X;\nexport function mixin<T extends {}, U extends {}, V extends {}, W extends {}>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W\n): T & U & V & W;\nexport function mixin<T extends {}, U extends {}, V extends {}>(target: T, source1: U, source2: V): T & U & V;\nexport function mixin<T extends {}, U extends {}>(target: T, source: U): T & U;\nexport function mixin(target: any, ...sources: any[]): any {\n\treturn _mixin({\n\t\tdeep: false,\n\t\tinherited: true,\n\t\tsources: sources,\n\t\ttarget: target\n\t});\n}\n\n/**\n * Returns a function which invokes the given function with the given arguments prepended to its argument list.\n * Like `Function.prototype.bind`, but does not alter execution context.\n *\n * @param targetFunction The function that needs to be bound\n * @param suppliedArgs An optional array of arguments to prepend to the `targetFunction` arguments list\n * @return The bound function\n */\nexport function partial(targetFunction: (...args: any[]) => any, ...suppliedArgs: any[]): (...args: any[]) => any {\n\treturn function(this: any) {\n\t\tconst args: any[] = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n\n\t\treturn targetFunction.apply(this, args);\n\t};\n}\n\n/**\n * Returns an object with a destroy method that, when called, calls the passed-in destructor.\n * This is intended to provide a unified interface for creating \"remove\" / \"destroy\" handlers for\n * event listeners, timers, etc.\n *\n * @param destructor A function that will be called when the handle's `destroy` method is invoked\n * @return The handle object\n */\nexport function createHandle(destructor: () => void): Handle {\n\tlet called = false;\n\treturn {\n\t\tdestroy: function(this: Handle) {\n\t\t\tif (!called) {\n\t\t\t\tcalled = true;\n\t\t\t\tdestructor();\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Returns a single handle that can be used to destroy multiple handles simultaneously.\n *\n * @param handles An array of handles with `destroy` methods\n * @return The handle object\n */\nexport function createCompositeHandle(...handles: Handle[]): Handle {\n\treturn createHandle(function() {\n\t\tfor (let i = 0; i < handles.length; i++) {\n\t\t\thandles[i].destroy();\n\t\t}\n\t});\n}\n"]}