{"version":3,"file":"Response.mjs","sourceRoot":"","sources":["Response.ts"],"names":[],"mappings":"AAAA,OAAO,OAAO,MAAM,oBAAoB,CAAC;AAUzC;IAYC,IAAI;QACH,MAAM,CAAM,IAAI,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC1C,CAAC;CAMD;AAED,eAAe,QAAQ,CAAC;AAExB,MAAM,+BAAkC,MAAkB;IACzD,MAAM,CAAC,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACtC,MAAM,CAAC,MAAM,GAAG;YACf,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QACxB,CAAC,CAAC;QACF,MAAM,CAAC,OAAO,GAAG;YAChB,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACtB,CAAC,CAAC;IACH,CAAC,CAAC,CAAC;AACJ,CAAC;AAED,MAAM,0BAA0B,IAAU;IACzC,MAAM,MAAM,GAAG,IAAI,UAAU,EAAE,CAAC;IAChC,MAAM,OAAO,GAAG,oBAAoB,CAAS,MAAM,CAAC,CAAC;IACrD,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;IACxB,MAAM,CAAC,OAAO,CAAC;AAChB,CAAC;AAED,MAAM,iCAAiC,IAAU;IAChD,MAAM,MAAM,GAAG,IAAI,UAAU,EAAE,CAAC;IAChC,MAAM,OAAO,GAAG,oBAAoB,CAAc,MAAM,CAAC,CAAC;IAC1D,MAAM,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;IAC/B,MAAM,CAAC,OAAO,CAAC;AAChB,CAAC;AAED,MAAM,iCAAiC,MAAmB;IACzD,MAAM,IAAI,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC;IACpC,MAAM,KAAK,GAAa,EAAE,CAAC;IAE3B,IAAI,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,KAAK,EAAE,EAAE;QAChC,KAAK,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;IAC9C,CAAC,CAAC,CAAC;IAEH,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AACvB,CAAC","sourcesContent":["import Promise from '../../shim/Promise';\nimport Task from '../async/Task';\nimport { Headers, Response as ResponseInterface, RequestOptions } from './interfaces';\nimport Observable from '../Observable';\n\nexport interface ResponseData {\n\ttask: Task<any>;\n\tused: boolean;\n}\n\nabstract class Response implements ResponseInterface {\n\tabstract readonly headers: Headers;\n\tabstract readonly ok: boolean;\n\tabstract readonly status: number;\n\tabstract readonly statusText: string;\n\tabstract readonly url: string;\n\tabstract readonly bodyUsed: boolean;\n\tabstract readonly requestOptions: RequestOptions;\n\n\tabstract readonly download: Observable<number>;\n\tabstract readonly data: Observable<any>;\n\n\tjson<T>(): Task<T> {\n\t\treturn <any>this.text().then(JSON.parse);\n\t}\n\n\tabstract arrayBuffer(): Task<ArrayBuffer>;\n\tabstract blob(): Task<Blob>;\n\tabstract formData(): Task<FormData>;\n\tabstract text(): Task<string>;\n}\n\nexport default Response;\n\nexport function getFileReaderPromise<T>(reader: FileReader): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\treader.onload = function() {\n\t\t\tresolve(reader.result);\n\t\t};\n\t\treader.onerror = function() {\n\t\t\treject(reader.error);\n\t\t};\n\t});\n}\n\nexport function getTextFromBlob(blob: Blob) {\n\tconst reader = new FileReader();\n\tconst promise = getFileReaderPromise<string>(reader);\n\treader.readAsText(blob);\n\treturn promise;\n}\n\nexport function getArrayBufferFromBlob(blob: Blob) {\n\tconst reader = new FileReader();\n\tconst promise = getFileReaderPromise<ArrayBuffer>(reader);\n\treader.readAsArrayBuffer(blob);\n\treturn promise;\n}\n\nexport function getTextFromArrayBuffer(buffer: ArrayBuffer) {\n\tconst view = new Uint8Array(buffer);\n\tconst chars: string[] = [];\n\n\tview.forEach((charCode, index) => {\n\t\tchars[index] = String.fromCharCode(charCode);\n\t});\n\n\treturn chars.join('');\n}\n"]}