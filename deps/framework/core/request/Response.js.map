{"version":3,"file":"Response.js","sourceRoot":"","sources":["Response.ts"],"names":[],"mappings":";;;;;;;;;;;IAAA,8CAAyC;IAUzC;QAAA;QAoBA,CAAC;QARA,uBAAI,GAAJ;YACC,MAAM,CAAM,IAAI,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC1C,CAAC;QAMF,eAAC;IAAD,CAAC,AApBD,IAoBC;IAED,kBAAe,QAAQ,CAAC;IAExB,8BAAwC,MAAkB;QACzD,MAAM,CAAC,IAAI,iBAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAClC,MAAM,CAAC,MAAM,GAAG;gBACf,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YACxB,CAAC,CAAC;YACF,MAAM,CAAC,OAAO,GAAG;gBAChB,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACtB,CAAC,CAAC;QACH,CAAC,CAAC,CAAC;IACJ,CAAC;IATD,oDASC;IAED,yBAAgC,IAAU;QACzC,IAAM,MAAM,GAAG,IAAI,UAAU,EAAE,CAAC;QAChC,IAAM,OAAO,GAAG,oBAAoB,CAAS,MAAM,CAAC,CAAC;QACrD,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACxB,MAAM,CAAC,OAAO,CAAC;IAChB,CAAC;IALD,0CAKC;IAED,gCAAuC,IAAU;QAChD,IAAM,MAAM,GAAG,IAAI,UAAU,EAAE,CAAC;QAChC,IAAM,OAAO,GAAG,oBAAoB,CAAc,MAAM,CAAC,CAAC;QAC1D,MAAM,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;QAC/B,MAAM,CAAC,OAAO,CAAC;IAChB,CAAC;IALD,wDAKC;IAED,gCAAuC,MAAmB;QACzD,IAAM,IAAI,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC;QACpC,IAAM,KAAK,GAAa,EAAE,CAAC;QAE3B,IAAI,CAAC,OAAO,CAAC,UAAC,QAAQ,EAAE,KAAK;YAC5B,KAAK,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAC9C,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACvB,CAAC;IATD,wDASC","sourcesContent":["import Promise from '../../shim/Promise';\nimport Task from '../async/Task';\nimport { Headers, Response as ResponseInterface, RequestOptions } from './interfaces';\nimport Observable from '../Observable';\n\nexport interface ResponseData {\n\ttask: Task<any>;\n\tused: boolean;\n}\n\nabstract class Response implements ResponseInterface {\n\tabstract readonly headers: Headers;\n\tabstract readonly ok: boolean;\n\tabstract readonly status: number;\n\tabstract readonly statusText: string;\n\tabstract readonly url: string;\n\tabstract readonly bodyUsed: boolean;\n\tabstract readonly requestOptions: RequestOptions;\n\n\tabstract readonly download: Observable<number>;\n\tabstract readonly data: Observable<any>;\n\n\tjson<T>(): Task<T> {\n\t\treturn <any>this.text().then(JSON.parse);\n\t}\n\n\tabstract arrayBuffer(): Task<ArrayBuffer>;\n\tabstract blob(): Task<Blob>;\n\tabstract formData(): Task<FormData>;\n\tabstract text(): Task<string>;\n}\n\nexport default Response;\n\nexport function getFileReaderPromise<T>(reader: FileReader): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\treader.onload = function() {\n\t\t\tresolve(reader.result);\n\t\t};\n\t\treader.onerror = function() {\n\t\t\treject(reader.error);\n\t\t};\n\t});\n}\n\nexport function getTextFromBlob(blob: Blob) {\n\tconst reader = new FileReader();\n\tconst promise = getFileReaderPromise<string>(reader);\n\treader.readAsText(blob);\n\treturn promise;\n}\n\nexport function getArrayBufferFromBlob(blob: Blob) {\n\tconst reader = new FileReader();\n\tconst promise = getFileReaderPromise<ArrayBuffer>(reader);\n\treader.readAsArrayBuffer(blob);\n\treturn promise;\n}\n\nexport function getTextFromArrayBuffer(buffer: ArrayBuffer) {\n\tconst view = new Uint8Array(buffer);\n\tconst chars: string[] = [];\n\n\tview.forEach((charCode, index) => {\n\t\tchars[index] = String.fromCharCode(charCode);\n\t});\n\n\treturn chars.join('');\n}\n"]}