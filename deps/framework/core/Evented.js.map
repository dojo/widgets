{"version":3,"file":"Evented.js","sourceRoot":"","sources":["Evented.ts"],"names":[],"mappings":"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","sourcesContent":["import Map from '../shim/Map';\nimport { Handle, EventType, EventObject } from './interfaces';\nimport { Destroyable } from './Destroyable';\n\n/**\n * Map of computed regular expressions, keyed by string\n */\nconst regexMap = new Map<string, RegExp>();\n\n/**\n * Determines is the event type glob has been matched\n *\n * @returns boolean that indicates if the glob is matched\n */\nexport function isGlobMatch(globString: string | symbol, targetString: string | symbol): boolean {\n\tif (typeof targetString === 'string' && typeof globString === 'string' && globString.indexOf('*') !== -1) {\n\t\tlet regex: RegExp;\n\t\tif (regexMap.has(globString)) {\n\t\t\tregex = regexMap.get(globString)!;\n\t\t} else {\n\t\t\tregex = new RegExp(`^${globString.replace(/\\*/g, '.*')}$`);\n\t\t\tregexMap.set(globString, regex);\n\t\t}\n\t\treturn regex.test(targetString);\n\t} else {\n\t\treturn globString === targetString;\n\t}\n}\n\nexport type EventedCallback<T = EventType, E extends EventObject<T> = EventObject<T>> = {\n\t/**\n\t * A callback that takes an `event` argument\n\t *\n\t * @param event The event object\n\t */\n\n\t(event: E): boolean | void;\n};\n\nexport interface CustomEventTypes<T extends EventObject<any> = EventObject<any>> {\n\t[index: string]: T;\n}\n\n/**\n * A type which is either a targeted event listener or an array of listeners\n * @template T The type of target for the events\n * @template E The event type for the events\n */\nexport type EventedCallbackOrArray<T = EventType, E extends EventObject<T> = EventObject<T>> =\n\t| EventedCallback<T, E>\n\t| EventedCallback<T, E>[];\n\n/**\n * Event Class\n */\nexport class Evented<\n\tM extends CustomEventTypes = {},\n\tT = EventType,\n\tO extends EventObject<T> = EventObject<T>\n> extends Destroyable {\n\t// The following member is purely so TypeScript remembers the type of `M` when extending so\n\t// that the utilities in `on.ts` will work https://github.com/Microsoft/TypeScript/issues/20348\n\t// tslint:disable-next-line\n\tprotected __typeMap__?: M;\n\t/**\n\t * map of listeners keyed by event type\n\t */\n\tprotected listenersMap: Map<T | keyof M, EventedCallback<T, O>[]> = new Map();\n\n\t/**\n\t * Emits the event object for the specified type\n\t *\n\t * @param event the event to emit\n\t */\n\temit<K extends keyof M>(event: M[K]): void;\n\temit(event: O): void;\n\temit(event: any): void {\n\t\tthis.listenersMap.forEach((methods, type) => {\n\t\t\tif (isGlobMatch(type as any, event.type)) {\n\t\t\t\t[...methods].forEach((method) => {\n\t\t\t\t\tmethod.call(this, event);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Catch all handler for various call signatures. The signatures are defined in\n\t * `BaseEventedEvents`.  You can add your own event type -> handler types by extending\n\t * `BaseEventedEvents`.  See example for details.\n\t *\n\t * @param args\n\t *\n\t * @example\n\t *\n\t * interface WidgetBaseEvents extends BaseEventedEvents {\n\t *     (type: 'properties:changed', handler: PropertiesChangedHandler): Handle;\n\t * }\n\t * class WidgetBase extends Evented {\n\t *    on: WidgetBaseEvents;\n\t * }\n\t *\n\t * @return {any}\n\t */\n\ton<K extends keyof M>(type: K, listener: EventedCallbackOrArray<K, M[K]>): Handle;\n\ton(type: T, listener: EventedCallbackOrArray<T, O>): Handle;\n\ton(type: any, listener: EventedCallbackOrArray<any, any>): Handle {\n\t\tif (Array.isArray(listener)) {\n\t\t\tconst handles = listener.map((listener) => this._addListener(type, listener));\n\t\t\treturn {\n\t\t\t\tdestroy() {\n\t\t\t\t\thandles.forEach((handle) => handle.destroy());\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn this._addListener(type, listener);\n\t}\n\n\tprivate _addListener(type: T | keyof M, listener: EventedCallback<T, O>) {\n\t\tconst listeners = this.listenersMap.get(type) || [];\n\t\tlisteners.push(listener);\n\t\tthis.listenersMap.set(type, listeners);\n\t\treturn {\n\t\t\tdestroy: () => {\n\t\t\t\tconst listeners = this.listenersMap.get(type) || [];\n\t\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t\t}\n\t\t};\n\t}\n}\n\nexport default Evented;\n"]}