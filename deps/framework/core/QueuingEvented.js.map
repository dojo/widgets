{"version":3,"file":"QueuingEvented.js","sourceRoot":"","sources":["../../../../src/core/QueuingEvented.ts"],"names":[],"mappings":";;;;;;;;;;;;IACA,mCAA8B;IAC9B,qCAA2F;IAE3F;;;;;;OAMG;IACH;QAIU,0CAAgB;QAJ1B;YAAA,qEAyDC;YApDQ,YAAM,GAAwC,IAAI,aAAG,EAAE,CAAC;YAEzD,eAAS,GAAG,CAAC,CAAC;;QAkDtB,CAAC;QA9CA,6BAAI,GAAJ,UAAK,KAAU;YACd,iBAAM,IAAI,YAAC,KAAK,CAAC,CAAC;YAElB,IAAI,QAAQ,GAAG,KAAK,CAAC;YAErB,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAC,MAAM,EAAE,IAAI;gBACtC,kHAAkH;gBAClH,EAAE,CAAC,CAAC,qBAAW,CAAC,IAAW,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC1C,QAAQ,GAAG,IAAI,CAAC;gBACjB,CAAC;YACF,CAAC,CAAC,CAAC;YAEH,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACf,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;gBAExC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;oBACZ,KAAK,GAAG,EAAE,CAAC;oBACX,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;gBACpC,CAAC;gBAED,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAElB,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;oBACxB,OAAO,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;wBACtC,KAAK,CAAC,KAAK,EAAE,CAAC;oBACf,CAAC;gBACF,CAAC;YACF,CAAC;QACF,CAAC;QAID,2BAAE,GAAF,UAAG,IAAS,EAAE,QAA0C;YAAxD,iBAaC;YAZA,IAAI,MAAM,GAAG,iBAAM,EAAE,YAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;YAEtC,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAC,MAAM,EAAE,YAAY;gBAC9C,KAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAC,MAAM,EAAE,UAAU;oBACtC,EAAE,CAAC,CAAC,qBAAW,CAAC,YAAmB,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC;wBAClD,MAAM,CAAC,OAAO,CAAC,UAAC,KAAK,IAAK,OAAA,KAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAhB,CAAgB,CAAC,CAAC;wBAC5C,KAAI,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;oBAChC,CAAC;gBACF,CAAC,CAAC,CAAC;YACJ,CAAC,CAAC,CAAC;YAEH,MAAM,CAAC,MAAM,CAAC;QACf,CAAC;QACF,qBAAC;IAAD,CAAC,AAzDD,CAIU,iBAAO,GAqDhB;IAED,kBAAe,cAAc,CAAC","sourcesContent":["import { Handle, EventObject, EventType } from './interfaces';\nimport Map from '../shim/Map';\nimport Evented, { CustomEventTypes, isGlobMatch, EventedCallbackOrArray } from './Evented';\n\n/**\n * An implementation of the Evented class that queues up events when no listeners are\n * listening. When a listener is subscribed, the queue will be published to the listener.\n * When the queue is full, the oldest events will be discarded to make room for the newest ones.\n *\n * @property maxEvents  The number of events to queue before old events are discarded. If zero (default), an unlimited number of events is queued.\n */\nclass QueuingEvented<\n\tM extends CustomEventTypes = {},\n\tT = EventType,\n\tO extends EventObject<T> = EventObject<T>\n> extends Evented<M, T, O> {\n\tprivate _queue: Map<string | symbol, EventObject[]> = new Map();\n\n\tpublic maxEvents = 0;\n\n\temit<K extends keyof M>(event: M[K]): void;\n\temit(event: O): void;\n\temit(event: any): void {\n\t\tsuper.emit(event);\n\n\t\tlet hasMatch = false;\n\n\t\tthis.listenersMap.forEach((method, type) => {\n\t\t\t// Since `type` is generic, the compiler doesn't know what type it is and `isGlobMatch` requires `string | symbol`\n\t\t\tif (isGlobMatch(type as any, event.type)) {\n\t\t\t\thasMatch = true;\n\t\t\t}\n\t\t});\n\n\t\tif (!hasMatch) {\n\t\t\tlet queue = this._queue.get(event.type);\n\n\t\t\tif (!queue) {\n\t\t\t\tqueue = [];\n\t\t\t\tthis._queue.set(event.type, queue);\n\t\t\t}\n\n\t\t\tqueue.push(event);\n\n\t\t\tif (this.maxEvents > 0) {\n\t\t\t\twhile (queue.length > this.maxEvents) {\n\t\t\t\t\tqueue.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ton<K extends keyof M>(type: K, listener: EventedCallbackOrArray<K, M[K]>): Handle;\n\ton(type: T, listener: EventedCallbackOrArray<T, O>): Handle;\n\ton(type: any, listener: EventedCallbackOrArray<any, any>): Handle {\n\t\tlet handle = super.on(type, listener);\n\n\t\tthis.listenersMap.forEach((method, listenerType) => {\n\t\t\tthis._queue.forEach((events, queuedType) => {\n\t\t\t\tif (isGlobMatch(listenerType as any, queuedType)) {\n\t\t\t\t\tevents.forEach((event) => this.emit(event));\n\t\t\t\t\tthis._queue.delete(queuedType);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn handle;\n\t}\n}\n\nexport default QueuingEvented;\n"]}