{"version":3,"file":"ExtensiblePromise.js","sourceRoot":"","sources":["../../../../../src/core/async/ExtensiblePromise.ts"],"names":[],"mappings":";;;;;;;;;;;;IACA,gDAAwE;IACxE,8CAAuD;IACvD,6BAA2B;IAE3B;;;;;;OAMG;IACH,wBAA+B,QAA+B;QAC7D,IAAM,SAAS,GAAU,EAAE,CAAC;QAE5B,EAAE,CAAC,CAAC,sBAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC3B,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC1C,IAAM,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACzB,SAAS,CAAC,IAAI,CAAC,IAAI,YAAY,iBAAiB,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;YAC1E,CAAC;QACF,CAAC;QAAC,IAAI,CAAC,CAAC;;gBACP,GAAG,CAAC,CAAe,IAAA,aAAA,iBAAA,QAAQ,CAAA,kCAAA;oBAAtB,IAAM,IAAI,qBAAA;oBACd,SAAS,CAAC,IAAI,CAAC,IAAI,YAAY,iBAAiB,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;iBACzE;;;;;;;;;QACF,CAAC;QAED,MAAM,CAAC,SAAS,CAAC;;IAClB,CAAC;IAfD,wCAeC;IAKD;;;OAGG;IACH;QAiJC;;;;;;;;;;;WAWG;QACH,2BAAY,QAAqB;YAChC,IAAI,CAAC,QAAQ,GAAG,IAAI,iBAAO,CAAI,QAAQ,CAAC,CAAC;QAC1C,CAAC;QAtJD;;;;;WAKG;QACI,wBAAM,GAAb,UAAiB,MAAY;YAC5B,MAAM,CAAC,IAAI,IAAI,CAAC,UAAC,OAAO,EAAE,MAAM,IAAK,OAAA,MAAM,CAAC,MAAM,CAAC,EAAd,CAAc,CAAC,CAAC;QACtD,CAAC;QAmBM,yBAAO,GAAd,UAAe,KAA8B;YAC5C,MAAM,CAAC,IAAI,IAAI,CAAC,UAAC,OAAO,EAAE,MAAM,IAAK,OAAA,OAAO,CAAC,KAAK,CAAC,EAAd,CAAc,CAAC,CAAC;QACtD,CAAC;QAsDD;;;;;;;;;;WAUG;QACI,qBAAG,GAAV,UACC,QAAqD;YAErD,EAAE,CAAC,CAAC,CAAC,sBAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,qBAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACrD,IAAM,aAAW,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAE1C,MAAM,CAAC,IAAI,IAAI,CAAC,UAAC,OAAO,EAAE,MAAM;oBAC/B,iBAAO,CAAC,GAAG,CAAC,aAAW,CAAC,GAAG,CAAC,UAAC,GAAG,IAAK,OAAA,QAAQ,CAAC,GAAG,CAAC,EAAb,CAAa,CAAC,CAAC,CAAC,IAAI,CAAC,UAAC,cAAmB;wBAC7E,IAAM,WAAW,GAAyB,EAAE,CAAC;wBAE7C,cAAc,CAAC,OAAO,CAAC,UAAC,KAAQ,EAAE,KAAa;4BAC9C,WAAW,CAAC,aAAW,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC;wBACzC,CAAC,CAAC,CAAC;wBAEH,OAAO,CAAC,WAAW,CAAC,CAAC;oBACtB,CAAC,EAAE,MAAM,CAAC,CAAC;gBACZ,CAAC,CAAC,CAAC;YACJ,CAAC;YAED,MAAM,CAAC,IAAI,IAAI,CAAC,UAAC,OAAO,EAAE,MAAM;gBAC/B,iBAAO,CAAC,GAAG,CAAC,cAAc,CAAc,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;YAC1E,CAAC,CAAC,CAAC;QACJ,CAAC;QAED;;;;;WAKG;QACI,sBAAI,GAAX,UAAe,QAA+D;YAC7E,MAAM,CAAC,IAAI,IAAI,CAAC,UAAC,OAAO,EAAE,MAAM;gBAC/B,iBAAO,CAAC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;YAC9D,CAAC,CAAC,CAAC;QACJ,CAAC;QAwBD;;;;;;WAMG;QACH,iCAAK,GAAL,UACC,UAAiF;YAEjF,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;QACzC,CAAC;QAED;;;;;;;WAOG;QACH,gCAAI,GAAJ,UACC,WAAiF,EACjF,UAA0F;YAF3F,iBAyBC;YArBA,IAAM,QAAQ,GAAuB,UAAC,OAAO,EAAE,MAAM;gBACpD,iBAAiB,QAAiB,EAAE,YAAkC;oBACrE,IAAM,QAAQ,GAA6C,QAAQ,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,WAAW,CAAC;oBAE/F,EAAE,CAAC,CAAC,OAAO,QAAQ,KAAK,UAAU,CAAC,CAAC,CAAC;wBACpC,IAAI,CAAC;4BACJ,OAAO,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC,CAAC;wBACjC,CAAC;wBAAC,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;4BAChB,MAAM,CAAC,KAAK,CAAC,CAAC;wBACf,CAAC;oBACF,CAAC;oBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;wBACrB,MAAM,CAAC,YAAY,CAAC,CAAC;oBACtB,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACP,OAAO,CAAC,YAAwB,CAAC,CAAC;oBACnC,CAAC;gBACF,CAAC;gBAED,KAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;YACzE,CAAC,CAAC;YAEF,MAAM,CAAC,IAAK,IAAI,CAAC,WAAwC,CAAC,QAAQ,CAAC,CAAC;QACrE,CAAC;QAGF,wBAAC;IAAD,CAAC,AAlND,IAkNC;IAlNY,8CAAiB;IAoN9B,kBAAe,iBAAiB,CAAC","sourcesContent":["import { Thenable } from '../../shim/interfaces';\nimport { isArrayLike, isIterable, Iterable } from '../../shim/iterator';\nimport Promise, { Executor } from '../../shim/Promise';\nimport '../../shim/Symbol';\n\n/**\n * Take a list of values, and if any are ExtensiblePromise objects, insert the wrapped Promise in its place,\n * otherwise use the original object. We use this to help use the native Promise methods like `all` and `race`.\n *\n * @param iterable    The list of objects to iterate over\n * @returns {any[]}    The list of objects, as an array, with ExtensiblePromises being replaced by Promises.\n */\nexport function unwrapPromises(iterable: Iterable<any> | any[]): any[] {\n\tconst unwrapped: any[] = [];\n\n\tif (isArrayLike(iterable)) {\n\t\tfor (let i = 0; i < iterable.length; i++) {\n\t\t\tconst item = iterable[i];\n\t\t\tunwrapped.push(item instanceof ExtensiblePromise ? item._promise : item);\n\t\t}\n\t} else {\n\t\tfor (const item of iterable) {\n\t\t\tunwrapped.push(item instanceof ExtensiblePromise ? item._promise : item);\n\t\t}\n\t}\n\n\treturn unwrapped;\n}\n\nexport type DictionaryOfPromises<T> = { [_: string]: T | Promise<T> | Thenable<T> };\nexport type ListOfPromises<T> = Iterable<T | Thenable<T>>;\n\n/**\n * An extensible base to allow Promises to be extended in ES5. This class basically wraps a native Promise object,\n * giving an API like a native promise.\n */\nexport class ExtensiblePromise<T> {\n\t/**\n\t * Return a rejected promise wrapped in an ExtensiblePromise\n\t *\n\t * @param reason    The reason for the rejection\n\t * @returns An extensible promise\n\t */\n\tstatic reject<T>(reason?: any): ExtensiblePromise<never>;\n\n\t/**\n\t * Return a rejected promise wrapped in an ExtensiblePromise\n\t *\n\t * @param reason    The reason for the rejection\n\t * @returns An extensible promise\n\t */\n\tstatic reject<T>(reason?: any): ExtensiblePromise<T> {\n\t\treturn new this((resolve, reject) => reject(reason));\n\t}\n\n\t/**\n\t * Return a resolved promise wrapped in an ExtensiblePromise\n\t *\n\t * @param value The value to resolve the promise with\n\t *\n\t * @returns An extensible promise\n\t */\n\tstatic resolve<P extends ExtensiblePromise<void>>(): P;\n\n\t/**\n\t * Return a resolved promise wrapped in an ExtensiblePromise\n\t *\n\t * @param value The value to resolve the promise with\n\t *\n\t * @returns An extensible promise\n\t */\n\tstatic resolve<T, P extends ExtensiblePromise<T>>(value: T | PromiseLike<T>): P;\n\tstatic resolve(value?: any | PromiseLike<any>): ExtensiblePromise<any> {\n\t\treturn new this((resolve, reject) => resolve(value));\n\t}\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n\t * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n\t *\n\t * @example\n\t * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n\t * // { one: 1, two: 2 }\n\t *\n\t * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns An extensible promise\n\t */\n\tstatic all<T>(iterable: DictionaryOfPromises<T>): ExtensiblePromise<{ [key: string]: T }>;\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n\t * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n\t *\n\t * @example\n\t * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n\t * // { one: 1, two: 2 }\n\t *\n\t * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns An extensible promise\n\t */\n\tstatic all<T>(iterable: (T | Thenable<T>)[]): ExtensiblePromise<T[]>;\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n\t * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n\t *\n\t * @example\n\t * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n\t * // { one: 1, two: 2 }\n\t *\n\t * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns An extensible promise\n\t */\n\tstatic all<T>(iterable: T | Thenable<T>): ExtensiblePromise<T[]>;\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n\t * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n\t *\n\t * @example\n\t * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n\t * // { one: 1, two: 2 }\n\t *\n\t * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns An extensible promise\n\t */\n\tstatic all<T>(iterable: ListOfPromises<T>): ExtensiblePromise<T[]>;\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n\t * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n\t *\n\t * @example\n\t * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n\t * // { one: 1, two: 2 }\n\t *\n\t * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns An extensible promise\n\t */\n\tstatic all<T>(\n\t\titerable: DictionaryOfPromises<T> | ListOfPromises<T>\n\t): ExtensiblePromise<T[] | { [key: string]: T }> {\n\t\tif (!isArrayLike(iterable) && !isIterable(iterable)) {\n\t\t\tconst promiseKeys = Object.keys(iterable);\n\n\t\t\treturn new this((resolve, reject) => {\n\t\t\t\tPromise.all(promiseKeys.map((key) => iterable[key])).then((promiseResults: T[]) => {\n\t\t\t\t\tconst returnValue: { [key: string]: T } = {};\n\n\t\t\t\t\tpromiseResults.forEach((value: T, index: number) => {\n\t\t\t\t\t\treturnValue[promiseKeys[index]] = value;\n\t\t\t\t\t});\n\n\t\t\t\t\tresolve(returnValue);\n\t\t\t\t}, reject);\n\t\t\t});\n\t\t}\n\n\t\treturn new this((resolve, reject) => {\n\t\t\tPromise.all(unwrapPromises(<Iterable<T>>iterable)).then(resolve, reject);\n\t\t});\n\t}\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when one of the passed in objects have resolved\n\t *\n\t * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns {ExtensiblePromise}\n\t */\n\tstatic race<T>(iterable: Iterable<T | PromiseLike<T>> | (T | PromiseLike<T>)[]): ExtensiblePromise<T> {\n\t\treturn new this((resolve, reject) => {\n\t\t\tPromise.race(unwrapPromises(iterable)).then(resolve, reject);\n\t\t});\n\t}\n\n\t/**\n\t * @type {Promise}\n\t * The wrapped promise\n\t */\n\treadonly _promise: Promise<T>;\n\n\t/**\n\t * Creates a new extended Promise.\n\t *\n\t * @constructor\n\t *\n\t * @param executor\n\t * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t * starting the asynchronous operation when it is invoked.\n\t *\n\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t * successfully, or the `reject` function when the operation fails.\n\t */\n\tconstructor(executor: Executor<T>) {\n\t\tthis._promise = new Promise<T>(executor);\n\t}\n\n\t/**\n\t * Adds a callback to be invoked when the wrapped Promise is rejected.\n\t *\n\t * @param {Function} onRejected A function to call to handle the error. The parameter to the function will be the caught error.\n\t *\n\t * @returns {ExtensiblePromise}\n\t */\n\tcatch<TResult = never>(\n\t\tonRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null\n\t): ExtensiblePromise<T | TResult> {\n\t\treturn this.then(undefined, onRejected);\n\t}\n\n\t/**\n\t * Adds a callback to be invoked when the wrapped Promise resolves or is rejected.\n\t *\n\t * @param {Function} onFulfilled   A function to call to handle the resolution. The paramter to the function will be the resolved value, if any.\n\t * @param {Function} onRejected    A function to call to handle the error. The parameter to the function will be the caught error.\n\t *\n\t * @returns {ExtensiblePromise}\n\t */\n\tthen<TResult1 = T, TResult2 = never>(\n\t\tonFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n\t\tonRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2> | void) | undefined | null\n\t): ExtensiblePromise<TResult1 | TResult2> {\n\t\tconst executor: Executor<TResult1> = (resolve, reject) => {\n\t\t\tfunction handler(rejected: boolean, valueOrError: T | TResult1 | Error) {\n\t\t\t\tconst callback: ((value: any) => any) | null | undefined = rejected ? onRejected : onFulfilled;\n\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresolve(callback(valueOrError));\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t} else if (rejected) {\n\t\t\t\t\treject(valueOrError);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(valueOrError as TResult1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._promise.then(handler.bind(null, false), handler.bind(null, true));\n\t\t};\n\n\t\treturn new (this.constructor as typeof ExtensiblePromise)(executor);\n\t}\n\n\treadonly [Symbol.toStringTag]: 'Promise';\n}\n\nexport default ExtensiblePromise;\n"]}