{"version":3,"file":"timing.js","sourceRoot":"","sources":["../../../../../src/core/async/timing.ts"],"names":[],"mappings":";;;;;;;;;;;;IAAA,yDAA0C;IAQ1C;;;;;OAKG;IACH,eAAyB,YAAoB;QAC5C,MAAM,CAAC,UAAS,KAAwB;YACvC,MAAM,CAAC,IAAI,2BAAO,CAAC,UAAS,OAAO;gBAClC,UAAU,CAAC;oBACV,OAAO,CAAC,OAAO,KAAK,KAAK,UAAU,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;gBACxD,CAAC,EAAE,YAAY,CAAC,CAAC;YAClB,CAAC,CAAC,CAAC;QACJ,CAAC,CAAC;IACH,CAAC;IARD,sBAQC;IAED;;;;;;OAMG;IACH,iBAA2B,YAAoB,EAAE,MAAa;QAC7D,IAAM,KAAK,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACzB,MAAM,CAAC,UAAS,KAAwB;YACvC,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,YAAY,GAAG,KAAK,CAAC,CAAC,CAAC;gBACvC,MAAM,CAAC,2BAAO,CAAC,MAAM,CAAI,MAAM,CAAC,CAAC;YAClC,CAAC;YACD,EAAE,CAAC,CAAC,OAAO,KAAK,KAAK,UAAU,CAAC,CAAC,CAAC;gBACjC,MAAM,CAAC,2BAAO,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,CAAC;YACjC,CAAC;YACD,MAAM,CAAC,2BAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAC/B,CAAC,CAAC;IACH,CAAC;IAXD,0BAWC;IAED;;;OAGG;IACH;QAAsC,4CAAY;QACjD;;;WAGG;QACH,0BAAY,YAAoB,EAAE,MAAc;YAAhD,YACC,kBAAM,cAAO,CAAC,CAAC,SAOf;YALA,MAAM,CAAC,IAAI,2BAAO,CAAC,UAAS,OAAO,EAAE,MAAM;gBAC1C,UAAU,CAAC;oBACV,MAAM,CAAC,MAAM,CAAC,CAAC;gBAChB,CAAC,EAAE,YAAY,CAAC,CAAC;YAClB,CAAC,CAAC,CAAC;QACJ,CAAC;QACF,uBAAC;IAAD,CAAC,AAdD,CAAsC,2BAAO,GAc5C;IAdY,4CAAgB","sourcesContent":["import Promise from './ExtensiblePromise';\nimport { Thenable } from '../../shim/interfaces';\n\nexport type IdentityValue<T> = T | (() => T | Thenable<T>);\nexport interface Identity<T> {\n\t(value?: IdentityValue<T>): Promise<T>;\n}\n\n/**\n * Used for delaying a Promise chain for a specific number of milliseconds.\n *\n * @param milliseconds the number of milliseconds to delay\n * @return {function (value: T | (() => T | Thenable<T>)): Promise<T>} a function producing a promise that eventually returns the value or executes the value function passed to it; usable with Thenable.then()\n */\nexport function delay<T>(milliseconds: number): Identity<T> {\n\treturn function(value?: IdentityValue<T>): Promise<T> {\n\t\treturn new Promise(function(resolve) {\n\t\t\tsetTimeout(function() {\n\t\t\t\tresolve(typeof value === 'function' ? value() : value);\n\t\t\t}, milliseconds);\n\t\t});\n\t};\n}\n\n/**\n * Reject a promise chain if a result hasn't been found before the timeout\n *\n * @param milliseconds after this number of milliseconds a rejection will be returned\n * @param reason The reason for the rejection\n * @return {function(T): Promise<T>} a function that produces a promise that is rejected or resolved based on your timeout\n */\nexport function timeout<T>(milliseconds: number, reason: Error): Identity<T> {\n\tconst start = Date.now();\n\treturn function(value?: IdentityValue<T>): Promise<T> {\n\t\tif (Date.now() - milliseconds > start) {\n\t\t\treturn Promise.reject<T>(reason);\n\t\t}\n\t\tif (typeof value === 'function') {\n\t\t\treturn Promise.resolve(value());\n\t\t}\n\t\treturn Promise.resolve(value);\n\t};\n}\n\n/**\n * A Promise that will reject itself automatically after a time.\n * Useful for combining with other promises in Promise.race.\n */\nexport class DelayedRejection extends Promise<any> {\n\t/**\n\t * @param milliseconds the number of milliseconds to wait before triggering a rejection\n\t * @param reason the reason for the rejection\n\t */\n\tconstructor(milliseconds: number, reason?: Error) {\n\t\tsuper(() => {});\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tsetTimeout(() => {\n\t\t\t\treject(reason);\n\t\t\t}, milliseconds);\n\t\t});\n\t}\n}\n"]}