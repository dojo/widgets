{"version":3,"file":"iteration.mjs","sourceRoot":"","sources":["../../../../../src/core/async/iteration.ts"],"names":[],"mappings":"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","sourcesContent":["import * as array from '../../shim/array';\nimport { isArrayLike, Iterable } from '../../shim/iterator';\nimport Promise from '../../shim/Promise';\nimport { Thenable } from '../../shim/interfaces';\n\nfunction isThenable<T>(value: any): value is Thenable<T> {\n\treturn value && typeof value.then === 'function';\n}\n\ntype ValuesAndResults<T, U> = { values: T[] | undefined; results: U[] | undefined };\n\n/**\n * Processes all items and then applies the callback to each item and eventually returns an object containing the\n * processed values and callback results\n * @param items a list of synchronous/asynchronous values to process\n * @param callback a callback that maps values to synchronous/asynchronous results\n * @return a list of objects holding the synchronous values and synchronous results.\n */\nfunction processValuesAndCallback<T, U>(\n\titems: Iterable<T | Promise<T>> | (T | Thenable<T>)[],\n\tcallback: Mapper<T, U>\n): Promise<ValuesAndResults<T, U>> {\n\treturn Promise.all(items).then(function(results) {\n\t\tconst pass: (U | Promise<U>)[] = Array.prototype.map.call(results, callback);\n\t\treturn Promise.all(pass).then(function(pass) {\n\t\t\treturn { values: results, results: pass };\n\t\t});\n\t});\n}\n\n/**\n * Finds the index of the next value in a sparse array-like object\n * @param list the sparse array-like object\n * @param offset the starting offset\n * @return the offset of the next index with a value; or -1 if not found\n */\nfunction findNextValueIndex<T>(list: ArrayLike<T>, offset: number = -1): number {\n\toffset++;\n\tfor (let length = list.length; offset < length; offset++) {\n\t\tif (offset in list) {\n\t\t\treturn offset;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction findLastValueIndex(list: ArrayLike<any>, offset?: number): number {\n\toffset = (offset === undefined ? list.length : offset) - 1;\n\tfor (; offset >= 0; offset--) {\n\t\tif (offset in list) {\n\t\t\treturn offset;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction generalReduce<T, U>(\n\tfindNextIndex: (list: ArrayLike<any>, offset?: number) => number,\n\titems: Iterable<T | Promise<T>> | (T | Promise<T>)[],\n\tcallback: Reducer<T, U>,\n\tinitialValue?: U\n): Promise<U> {\n\tconst hasInitialValue = arguments.length > 3;\n\treturn Promise.all(items).then(function(results) {\n\t\treturn new Promise<U>(function(resolve, reject) {\n\t\t\t// As iterators do not have indices like `ArrayLike` objects, the results array\n\t\t\t// is used to determine the next value.\n\t\t\tconst list = isArrayLike(items) ? items : results;\n\t\t\tlet i: number;\n\t\t\tfunction next(currentValue: U | undefined): void {\n\t\t\t\ti = findNextIndex(list, i);\n\t\t\t\tif (i >= 0) {\n\t\t\t\t\tif (results) {\n\t\t\t\t\t\tif (currentValue) {\n\t\t\t\t\t\t\tconst result = callback(currentValue, results[i], i, results);\n\n\t\t\t\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\t\t\t\tresult.then(next, reject);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnext(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolve(currentValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet value: U | undefined;\n\t\t\tif (hasInitialValue) {\n\t\t\t\tvalue = initialValue;\n\t\t\t} else {\n\t\t\t\ti = findNextIndex(list);\n\n\t\t\t\tif (i < 0) {\n\t\t\t\t\tthrow new Error('reduce array with no initial value');\n\t\t\t\t}\n\t\t\t\tif (results) {\n\t\t\t\t\tvalue = <any>results[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext(value);\n\t\t});\n\t});\n}\n\nfunction testAndHaltOnCondition<T>(\n\tcondition: boolean,\n\titems: Iterable<T | Promise<T>> | (T | Promise<T>)[],\n\tcallback: Filterer<T>\n): Promise<boolean> {\n\treturn Promise.all(items).then(function(results) {\n\t\treturn new Promise<boolean>(function(resolve) {\n\t\t\tlet result: boolean | Thenable<boolean>;\n\t\t\tlet pendingCount = 0;\n\t\t\tif (results) {\n\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\tresult = callback(results[i], i, results);\n\t\t\t\t\tif (result === condition) {\n\t\t\t\t\t\treturn resolve(result);\n\t\t\t\t\t} else if (isThenable(result)) {\n\t\t\t\t\t\tpendingCount++;\n\t\t\t\t\t\tresult.then(function(result) {\n\t\t\t\t\t\t\tif (result === condition) {\n\t\t\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpendingCount--;\n\t\t\t\t\t\t\tif (pendingCount === 0) {\n\t\t\t\t\t\t\t\tresolve(!condition);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pendingCount === 0) {\n\t\t\t\tresolve(!condition);\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Test whether all elements in the array pass the provided callback\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return eventually returns true if all values pass; otherwise false\n */\nexport function every<T>(\n\titems: Iterable<T | Promise<T>> | (T | Promise<T>)[],\n\tcallback: Filterer<T>\n): Promise<boolean> {\n\treturn testAndHaltOnCondition(false, items, callback);\n}\n\n/**\n * Returns an array of elements which pass the provided callback\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return eventually returns a new array with only values that have passed\n */\nexport function filter<T>(items: Iterable<T | Promise<T>> | (T | Promise<T>)[], callback: Filterer<T>): Promise<T[]> {\n\treturn processValuesAndCallback(items, callback).then(function(result) {\n\t\tlet arr: T[] = [];\n\t\tif (result && result.results && result.values) {\n\t\t\tfor (let i = 0; i < result.results.length; i++) {\n\t\t\t\tresult.results[i] && arr.push(result.values[i]);\n\t\t\t}\n\t\t}\n\t\treturn arr;\n\t});\n}\n\n/**\n * Find the first value matching a filter function\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return a promise eventually containing the item or undefined if a match is not found\n */\nexport function find<T>(\n\titems: Iterable<T | Promise<T>> | (T | Promise<T>)[],\n\tcallback: Filterer<T>\n): Promise<T | undefined> {\n\tconst list = isArrayLike(items) ? items : array.from(items);\n\treturn findIndex(list, callback).then<T | undefined>(function(i) {\n\t\treturn i !== undefined && i >= 0 ? list[i] : undefined;\n\t});\n}\n\n/**\n * Find the first index with a value matching the filter function\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return a promise eventually containing the index of the matching item or -1 if a match is not found\n */\nexport function findIndex<T>(\n\titems: Iterable<T | Promise<T>> | (T | Thenable<T>)[],\n\tcallback: Filterer<T>\n): Promise<number> {\n\t// TODO we can improve this by returning immediately\n\treturn processValuesAndCallback(items, callback).then(function(result: ValuesAndResults<T, boolean>) {\n\t\tif (result && result.results) {\n\t\t\tfor (let i = 0; i < result.results.length; i++) {\n\t\t\t\tif (result.results[i]) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t});\n}\n\n/**\n * transform a list of items using a mapper function\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous transform function\n * @return a promise eventually containing a collection of each transformed value\n */\nexport function map<T, U>(\n\titems: Iterable<T | Promise<T>> | (T | Promise<T>)[],\n\tcallback: Mapper<T, U>\n): Promise<U[] | null | undefined> {\n\treturn processValuesAndCallback(items, callback).then(function(result) {\n\t\treturn result ? result.results : null;\n\t});\n}\n\n/**\n * reduce a list of items down to a single value\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous reducer function\n * @param [initialValue] the first value to pass to the callback\n * @return a promise eventually containing a value that is the result of the reduction\n */\nexport function reduce<T, U>(\n\tthis: any,\n\titems: Iterable<T | Promise<T>> | (T | Promise<T>)[],\n\tcallback: Reducer<T, U>,\n\tinitialValue?: U\n): Promise<U> {\n\tconst args: any[] = <any[]>array.from(arguments);\n\targs.unshift(findNextValueIndex);\n\treturn generalReduce.apply(this, args);\n}\n\nexport function reduceRight<T, U>(\n\tthis: any,\n\titems: Iterable<T | Promise<T>> | (T | Promise<T>)[],\n\tcallback: Reducer<T, U>,\n\tinitialValue?: U\n): Promise<U> {\n\tconst args: any[] = <any[]>array.from(arguments);\n\targs.unshift(findLastValueIndex);\n\treturn generalReduce.apply(this, args);\n}\n\nexport function series<T, U>(\n\titems: Iterable<T | Promise<T>> | (T | Promise<T>)[],\n\toperation: Mapper<T, U>\n): Promise<U[]> {\n\treturn generalReduce(\n\t\tfindNextValueIndex,\n\t\titems,\n\t\tfunction(previousValue, currentValue: T, index: number, array: T[]) {\n\t\t\tconst result = operation(currentValue, index, array);\n\n\t\t\tif (isThenable(result)) {\n\t\t\t\treturn result.then(function(value) {\n\t\t\t\t\tpreviousValue.push(value);\n\t\t\t\t\treturn previousValue;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tpreviousValue.push(result);\n\t\t\treturn previousValue;\n\t\t},\n\t\t[] as U[]\n\t);\n}\n\nexport function some<T>(\n\titems: Iterable<T | Promise<T>> | Array<T | Promise<T>>,\n\tcallback: Filterer<T>\n): Promise<boolean> {\n\treturn testAndHaltOnCondition(true, items, callback);\n}\n\nexport interface Filterer<T> extends Mapper<T, boolean> {}\n\nexport interface Mapper<T, U> {\n\t(value: T, index: number, array: T[]): U | Thenable<U>;\n}\n\nexport interface Reducer<T, U> {\n\t(previousValue: U, currentValue: T, index: number, array: T[]): U | Thenable<U>;\n}\n"]}