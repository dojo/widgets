{"version":3,"file":"ExtensiblePromise.mjs","sourceRoot":"","sources":["../../../../../src/core/async/ExtensiblePromise.ts"],"names":[],"mappings":"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","sourcesContent":["import { Thenable } from '../../shim/interfaces';\nimport { isArrayLike, isIterable, Iterable } from '../../shim/iterator';\nimport Promise, { Executor } from '../../shim/Promise';\nimport '../../shim/Symbol';\n\n/**\n * Take a list of values, and if any are ExtensiblePromise objects, insert the wrapped Promise in its place,\n * otherwise use the original object. We use this to help use the native Promise methods like `all` and `race`.\n *\n * @param iterable    The list of objects to iterate over\n * @returns {any[]}    The list of objects, as an array, with ExtensiblePromises being replaced by Promises.\n */\nexport function unwrapPromises(iterable: Iterable<any> | any[]): any[] {\n\tconst unwrapped: any[] = [];\n\n\tif (isArrayLike(iterable)) {\n\t\tfor (let i = 0; i < iterable.length; i++) {\n\t\t\tconst item = iterable[i];\n\t\t\tunwrapped.push(item instanceof ExtensiblePromise ? item._promise : item);\n\t\t}\n\t} else {\n\t\tfor (const item of iterable) {\n\t\t\tunwrapped.push(item instanceof ExtensiblePromise ? item._promise : item);\n\t\t}\n\t}\n\n\treturn unwrapped;\n}\n\nexport type DictionaryOfPromises<T> = { [_: string]: T | Promise<T> | Thenable<T> };\nexport type ListOfPromises<T> = Iterable<T | Thenable<T>>;\n\n/**\n * An extensible base to allow Promises to be extended in ES5. This class basically wraps a native Promise object,\n * giving an API like a native promise.\n */\nexport class ExtensiblePromise<T> {\n\t/**\n\t * Return a rejected promise wrapped in an ExtensiblePromise\n\t *\n\t * @param reason    The reason for the rejection\n\t * @returns An extensible promise\n\t */\n\tstatic reject<T>(reason?: any): ExtensiblePromise<never>;\n\n\t/**\n\t * Return a rejected promise wrapped in an ExtensiblePromise\n\t *\n\t * @param reason    The reason for the rejection\n\t * @returns An extensible promise\n\t */\n\tstatic reject<T>(reason?: any): ExtensiblePromise<T> {\n\t\treturn new this((resolve, reject) => reject(reason));\n\t}\n\n\t/**\n\t * Return a resolved promise wrapped in an ExtensiblePromise\n\t *\n\t * @param value The value to resolve the promise with\n\t *\n\t * @returns An extensible promise\n\t */\n\tstatic resolve<P extends ExtensiblePromise<void>>(): P;\n\n\t/**\n\t * Return a resolved promise wrapped in an ExtensiblePromise\n\t *\n\t * @param value The value to resolve the promise with\n\t *\n\t * @returns An extensible promise\n\t */\n\tstatic resolve<T, P extends ExtensiblePromise<T>>(value: T | PromiseLike<T>): P;\n\tstatic resolve(value?: any | PromiseLike<any>): ExtensiblePromise<any> {\n\t\treturn new this((resolve, reject) => resolve(value));\n\t}\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n\t * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n\t *\n\t * @example\n\t * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n\t * // { one: 1, two: 2 }\n\t *\n\t * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns An extensible promise\n\t */\n\tstatic all<T>(iterable: DictionaryOfPromises<T>): ExtensiblePromise<{ [key: string]: T }>;\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n\t * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n\t *\n\t * @example\n\t * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n\t * // { one: 1, two: 2 }\n\t *\n\t * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns An extensible promise\n\t */\n\tstatic all<T>(iterable: (T | Thenable<T>)[]): ExtensiblePromise<T[]>;\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n\t * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n\t *\n\t * @example\n\t * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n\t * // { one: 1, two: 2 }\n\t *\n\t * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns An extensible promise\n\t */\n\tstatic all<T>(iterable: T | Thenable<T>): ExtensiblePromise<T[]>;\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n\t * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n\t *\n\t * @example\n\t * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n\t * // { one: 1, two: 2 }\n\t *\n\t * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns An extensible promise\n\t */\n\tstatic all<T>(iterable: ListOfPromises<T>): ExtensiblePromise<T[]>;\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n\t * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n\t *\n\t * @example\n\t * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n\t * // { one: 1, two: 2 }\n\t *\n\t * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns An extensible promise\n\t */\n\tstatic all<T>(\n\t\titerable: DictionaryOfPromises<T> | ListOfPromises<T>\n\t): ExtensiblePromise<T[] | { [key: string]: T }> {\n\t\tif (!isArrayLike(iterable) && !isIterable(iterable)) {\n\t\t\tconst promiseKeys = Object.keys(iterable);\n\n\t\t\treturn new this((resolve, reject) => {\n\t\t\t\tPromise.all(promiseKeys.map((key) => iterable[key])).then((promiseResults: T[]) => {\n\t\t\t\t\tconst returnValue: { [key: string]: T } = {};\n\n\t\t\t\t\tpromiseResults.forEach((value: T, index: number) => {\n\t\t\t\t\t\treturnValue[promiseKeys[index]] = value;\n\t\t\t\t\t});\n\n\t\t\t\t\tresolve(returnValue);\n\t\t\t\t}, reject);\n\t\t\t});\n\t\t}\n\n\t\treturn new this((resolve, reject) => {\n\t\t\tPromise.all(unwrapPromises(<Iterable<T>>iterable)).then(resolve, reject);\n\t\t});\n\t}\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when one of the passed in objects have resolved\n\t *\n\t * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns {ExtensiblePromise}\n\t */\n\tstatic race<T>(iterable: Iterable<T | PromiseLike<T>> | (T | PromiseLike<T>)[]): ExtensiblePromise<T> {\n\t\treturn new this((resolve, reject) => {\n\t\t\tPromise.race(unwrapPromises(iterable)).then(resolve, reject);\n\t\t});\n\t}\n\n\t/**\n\t * @type {Promise}\n\t * The wrapped promise\n\t */\n\treadonly _promise: Promise<T>;\n\n\t/**\n\t * Creates a new extended Promise.\n\t *\n\t * @constructor\n\t *\n\t * @param executor\n\t * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t * starting the asynchronous operation when it is invoked.\n\t *\n\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t * successfully, or the `reject` function when the operation fails.\n\t */\n\tconstructor(executor: Executor<T>) {\n\t\tthis._promise = new Promise<T>(executor);\n\t}\n\n\t/**\n\t * Adds a callback to be invoked when the wrapped Promise is rejected.\n\t *\n\t * @param {Function} onRejected A function to call to handle the error. The parameter to the function will be the caught error.\n\t *\n\t * @returns {ExtensiblePromise}\n\t */\n\tcatch<TResult = never>(\n\t\tonRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null\n\t): ExtensiblePromise<T | TResult> {\n\t\treturn this.then(undefined, onRejected);\n\t}\n\n\t/**\n\t * Adds a callback to be invoked when the wrapped Promise resolves or is rejected.\n\t *\n\t * @param {Function} onFulfilled   A function to call to handle the resolution. The paramter to the function will be the resolved value, if any.\n\t * @param {Function} onRejected    A function to call to handle the error. The parameter to the function will be the caught error.\n\t *\n\t * @returns {ExtensiblePromise}\n\t */\n\tthen<TResult1 = T, TResult2 = never>(\n\t\tonFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n\t\tonRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2> | void) | undefined | null\n\t): ExtensiblePromise<TResult1 | TResult2> {\n\t\tconst executor: Executor<TResult1> = (resolve, reject) => {\n\t\t\tfunction handler(rejected: boolean, valueOrError: T | TResult1 | Error) {\n\t\t\t\tconst callback: ((value: any) => any) | null | undefined = rejected ? onRejected : onFulfilled;\n\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresolve(callback(valueOrError));\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t} else if (rejected) {\n\t\t\t\t\treject(valueOrError);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(valueOrError as TResult1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._promise.then(handler.bind(null, false), handler.bind(null, true));\n\t\t};\n\n\t\treturn new (this.constructor as typeof ExtensiblePromise)(executor);\n\t}\n\n\treadonly [Symbol.toStringTag]: 'Promise';\n}\n\nexport default ExtensiblePromise;\n"]}