{"version":3,"file":"iteration.js","sourceRoot":"","sources":["../../../../../src/core/async/iteration.ts"],"names":[],"mappings":"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","sourcesContent":["import * as array from '../../shim/array';\nimport { isArrayLike, Iterable } from '../../shim/iterator';\nimport Promise from '../../shim/Promise';\nimport { Thenable } from '../../shim/interfaces';\n\nfunction isThenable<T>(value: any): value is Thenable<T> {\n\treturn value && typeof value.then === 'function';\n}\n\ntype ValuesAndResults<T, U> = { values: T[] | undefined; results: U[] | undefined };\n\n/**\n * Processes all items and then applies the callback to each item and eventually returns an object containing the\n * processed values and callback results\n * @param items a list of synchronous/asynchronous values to process\n * @param callback a callback that maps values to synchronous/asynchronous results\n * @return a list of objects holding the synchronous values and synchronous results.\n */\nfunction processValuesAndCallback<T, U>(\n\titems: Iterable<T | Promise<T>> | (T | Thenable<T>)[],\n\tcallback: Mapper<T, U>\n): Promise<ValuesAndResults<T, U>> {\n\treturn Promise.all(items).then(function(results) {\n\t\tconst pass: (U | Promise<U>)[] = Array.prototype.map.call(results, callback);\n\t\treturn Promise.all(pass).then(function(pass) {\n\t\t\treturn { values: results, results: pass };\n\t\t});\n\t});\n}\n\n/**\n * Finds the index of the next value in a sparse array-like object\n * @param list the sparse array-like object\n * @param offset the starting offset\n * @return the offset of the next index with a value; or -1 if not found\n */\nfunction findNextValueIndex<T>(list: ArrayLike<T>, offset: number = -1): number {\n\toffset++;\n\tfor (let length = list.length; offset < length; offset++) {\n\t\tif (offset in list) {\n\t\t\treturn offset;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction findLastValueIndex(list: ArrayLike<any>, offset?: number): number {\n\toffset = (offset === undefined ? list.length : offset) - 1;\n\tfor (; offset >= 0; offset--) {\n\t\tif (offset in list) {\n\t\t\treturn offset;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction generalReduce<T, U>(\n\tfindNextIndex: (list: ArrayLike<any>, offset?: number) => number,\n\titems: Iterable<T | Promise<T>> | (T | Promise<T>)[],\n\tcallback: Reducer<T, U>,\n\tinitialValue?: U\n): Promise<U> {\n\tconst hasInitialValue = arguments.length > 3;\n\treturn Promise.all(items).then(function(results) {\n\t\treturn new Promise<U>(function(resolve, reject) {\n\t\t\t// As iterators do not have indices like `ArrayLike` objects, the results array\n\t\t\t// is used to determine the next value.\n\t\t\tconst list = isArrayLike(items) ? items : results;\n\t\t\tlet i: number;\n\t\t\tfunction next(currentValue: U | undefined): void {\n\t\t\t\ti = findNextIndex(list, i);\n\t\t\t\tif (i >= 0) {\n\t\t\t\t\tif (results) {\n\t\t\t\t\t\tif (currentValue) {\n\t\t\t\t\t\t\tconst result = callback(currentValue, results[i], i, results);\n\n\t\t\t\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\t\t\t\tresult.then(next, reject);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnext(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolve(currentValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet value: U | undefined;\n\t\t\tif (hasInitialValue) {\n\t\t\t\tvalue = initialValue;\n\t\t\t} else {\n\t\t\t\ti = findNextIndex(list);\n\n\t\t\t\tif (i < 0) {\n\t\t\t\t\tthrow new Error('reduce array with no initial value');\n\t\t\t\t}\n\t\t\t\tif (results) {\n\t\t\t\t\tvalue = <any>results[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext(value);\n\t\t});\n\t});\n}\n\nfunction testAndHaltOnCondition<T>(\n\tcondition: boolean,\n\titems: Iterable<T | Promise<T>> | (T | Promise<T>)[],\n\tcallback: Filterer<T>\n): Promise<boolean> {\n\treturn Promise.all(items).then(function(results) {\n\t\treturn new Promise<boolean>(function(resolve) {\n\t\t\tlet result: boolean | Thenable<boolean>;\n\t\t\tlet pendingCount = 0;\n\t\t\tif (results) {\n\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\tresult = callback(results[i], i, results);\n\t\t\t\t\tif (result === condition) {\n\t\t\t\t\t\treturn resolve(result);\n\t\t\t\t\t} else if (isThenable(result)) {\n\t\t\t\t\t\tpendingCount++;\n\t\t\t\t\t\tresult.then(function(result) {\n\t\t\t\t\t\t\tif (result === condition) {\n\t\t\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpendingCount--;\n\t\t\t\t\t\t\tif (pendingCount === 0) {\n\t\t\t\t\t\t\t\tresolve(!condition);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pendingCount === 0) {\n\t\t\t\tresolve(!condition);\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Test whether all elements in the array pass the provided callback\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return eventually returns true if all values pass; otherwise false\n */\nexport function every<T>(\n\titems: Iterable<T | Promise<T>> | (T | Promise<T>)[],\n\tcallback: Filterer<T>\n): Promise<boolean> {\n\treturn testAndHaltOnCondition(false, items, callback);\n}\n\n/**\n * Returns an array of elements which pass the provided callback\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return eventually returns a new array with only values that have passed\n */\nexport function filter<T>(items: Iterable<T | Promise<T>> | (T | Promise<T>)[], callback: Filterer<T>): Promise<T[]> {\n\treturn processValuesAndCallback(items, callback).then(function(result) {\n\t\tlet arr: T[] = [];\n\t\tif (result && result.results && result.values) {\n\t\t\tfor (let i = 0; i < result.results.length; i++) {\n\t\t\t\tresult.results[i] && arr.push(result.values[i]);\n\t\t\t}\n\t\t}\n\t\treturn arr;\n\t});\n}\n\n/**\n * Find the first value matching a filter function\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return a promise eventually containing the item or undefined if a match is not found\n */\nexport function find<T>(\n\titems: Iterable<T | Promise<T>> | (T | Promise<T>)[],\n\tcallback: Filterer<T>\n): Promise<T | undefined> {\n\tconst list = isArrayLike(items) ? items : array.from(items);\n\treturn findIndex(list, callback).then<T | undefined>(function(i) {\n\t\treturn i !== undefined && i >= 0 ? list[i] : undefined;\n\t});\n}\n\n/**\n * Find the first index with a value matching the filter function\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return a promise eventually containing the index of the matching item or -1 if a match is not found\n */\nexport function findIndex<T>(\n\titems: Iterable<T | Promise<T>> | (T | Thenable<T>)[],\n\tcallback: Filterer<T>\n): Promise<number> {\n\t// TODO we can improve this by returning immediately\n\treturn processValuesAndCallback(items, callback).then(function(result: ValuesAndResults<T, boolean>) {\n\t\tif (result && result.results) {\n\t\t\tfor (let i = 0; i < result.results.length; i++) {\n\t\t\t\tif (result.results[i]) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t});\n}\n\n/**\n * transform a list of items using a mapper function\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous transform function\n * @return a promise eventually containing a collection of each transformed value\n */\nexport function map<T, U>(\n\titems: Iterable<T | Promise<T>> | (T | Promise<T>)[],\n\tcallback: Mapper<T, U>\n): Promise<U[] | null | undefined> {\n\treturn processValuesAndCallback(items, callback).then(function(result) {\n\t\treturn result ? result.results : null;\n\t});\n}\n\n/**\n * reduce a list of items down to a single value\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous reducer function\n * @param [initialValue] the first value to pass to the callback\n * @return a promise eventually containing a value that is the result of the reduction\n */\nexport function reduce<T, U>(\n\tthis: any,\n\titems: Iterable<T | Promise<T>> | (T | Promise<T>)[],\n\tcallback: Reducer<T, U>,\n\tinitialValue?: U\n): Promise<U> {\n\tconst args: any[] = <any[]>array.from(arguments);\n\targs.unshift(findNextValueIndex);\n\treturn generalReduce.apply(this, args);\n}\n\nexport function reduceRight<T, U>(\n\tthis: any,\n\titems: Iterable<T | Promise<T>> | (T | Promise<T>)[],\n\tcallback: Reducer<T, U>,\n\tinitialValue?: U\n): Promise<U> {\n\tconst args: any[] = <any[]>array.from(arguments);\n\targs.unshift(findLastValueIndex);\n\treturn generalReduce.apply(this, args);\n}\n\nexport function series<T, U>(\n\titems: Iterable<T | Promise<T>> | (T | Promise<T>)[],\n\toperation: Mapper<T, U>\n): Promise<U[]> {\n\treturn generalReduce(\n\t\tfindNextValueIndex,\n\t\titems,\n\t\tfunction(previousValue, currentValue: T, index: number, array: T[]) {\n\t\t\tconst result = operation(currentValue, index, array);\n\n\t\t\tif (isThenable(result)) {\n\t\t\t\treturn result.then(function(value) {\n\t\t\t\t\tpreviousValue.push(value);\n\t\t\t\t\treturn previousValue;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tpreviousValue.push(result);\n\t\t\treturn previousValue;\n\t\t},\n\t\t[] as U[]\n\t);\n}\n\nexport function some<T>(\n\titems: Iterable<T | Promise<T>> | Array<T | Promise<T>>,\n\tcallback: Filterer<T>\n): Promise<boolean> {\n\treturn testAndHaltOnCondition(true, items, callback);\n}\n\nexport interface Filterer<T> extends Mapper<T, boolean> {}\n\nexport interface Mapper<T, U> {\n\t(value: T, index: number, array: T[]): U | Thenable<U>;\n}\n\nexport interface Reducer<T, U> {\n\t(previousValue: U, currentValue: T, index: number, array: T[]): U | Thenable<U>;\n}\n"]}