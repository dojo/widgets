{"version":3,"file":"timing.mjs","sourceRoot":"","sources":["../../../../../src/core/async/timing.ts"],"names":[],"mappings":"AAAA,OAAO,OAAO,MAAM,qBAAqB,CAAC;AAQ1C;;;;;GAKG;AACH,MAAM,gBAAmB,YAAoB;IAC5C,MAAM,CAAC,UAAS,KAAwB;QACvC,MAAM,CAAC,IAAI,OAAO,CAAC,UAAS,OAAO;YAClC,UAAU,CAAC;gBACV,OAAO,CAAC,OAAO,KAAK,KAAK,UAAU,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;YACxD,CAAC,EAAE,YAAY,CAAC,CAAC;QAClB,CAAC,CAAC,CAAC;IACJ,CAAC,CAAC;AACH,CAAC;AAED;;;;;;GAMG;AACH,MAAM,kBAAqB,YAAoB,EAAE,MAAa;IAC7D,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;IACzB,MAAM,CAAC,UAAS,KAAwB;QACvC,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,YAAY,GAAG,KAAK,CAAC,CAAC,CAAC;YACvC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAI,MAAM,CAAC,CAAC;QAClC,CAAC;QACD,EAAE,CAAC,CAAC,OAAO,KAAK,KAAK,UAAU,CAAC,CAAC,CAAC;YACjC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,CAAC;QACjC,CAAC;QACD,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IAC/B,CAAC,CAAC;AACH,CAAC;AAED;;;GAGG;AACH,MAAM,uBAAwB,SAAQ,OAAY;IACjD;;;OAGG;IACH,YAAY,YAAoB,EAAE,MAAc;QAC/C,KAAK,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC,CAAC;QAEhB,MAAM,CAAC,IAAI,OAAO,CAAC,UAAS,OAAO,EAAE,MAAM;YAC1C,UAAU,CAAC,GAAG,EAAE;gBACf,MAAM,CAAC,MAAM,CAAC,CAAC;YAChB,CAAC,EAAE,YAAY,CAAC,CAAC;QAClB,CAAC,CAAC,CAAC;IACJ,CAAC;CACD","sourcesContent":["import Promise from './ExtensiblePromise';\nimport { Thenable } from '../../shim/interfaces';\n\nexport type IdentityValue<T> = T | (() => T | Thenable<T>);\nexport interface Identity<T> {\n\t(value?: IdentityValue<T>): Promise<T>;\n}\n\n/**\n * Used for delaying a Promise chain for a specific number of milliseconds.\n *\n * @param milliseconds the number of milliseconds to delay\n * @return {function (value: T | (() => T | Thenable<T>)): Promise<T>} a function producing a promise that eventually returns the value or executes the value function passed to it; usable with Thenable.then()\n */\nexport function delay<T>(milliseconds: number): Identity<T> {\n\treturn function(value?: IdentityValue<T>): Promise<T> {\n\t\treturn new Promise(function(resolve) {\n\t\t\tsetTimeout(function() {\n\t\t\t\tresolve(typeof value === 'function' ? value() : value);\n\t\t\t}, milliseconds);\n\t\t});\n\t};\n}\n\n/**\n * Reject a promise chain if a result hasn't been found before the timeout\n *\n * @param milliseconds after this number of milliseconds a rejection will be returned\n * @param reason The reason for the rejection\n * @return {function(T): Promise<T>} a function that produces a promise that is rejected or resolved based on your timeout\n */\nexport function timeout<T>(milliseconds: number, reason: Error): Identity<T> {\n\tconst start = Date.now();\n\treturn function(value?: IdentityValue<T>): Promise<T> {\n\t\tif (Date.now() - milliseconds > start) {\n\t\t\treturn Promise.reject<T>(reason);\n\t\t}\n\t\tif (typeof value === 'function') {\n\t\t\treturn Promise.resolve(value());\n\t\t}\n\t\treturn Promise.resolve(value);\n\t};\n}\n\n/**\n * A Promise that will reject itself automatically after a time.\n * Useful for combining with other promises in Promise.race.\n */\nexport class DelayedRejection extends Promise<any> {\n\t/**\n\t * @param milliseconds the number of milliseconds to wait before triggering a rejection\n\t * @param reason the reason for the rejection\n\t */\n\tconstructor(milliseconds: number, reason?: Error) {\n\t\tsuper(() => {});\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tsetTimeout(() => {\n\t\t\t\treject(reason);\n\t\t\t}, milliseconds);\n\t\t});\n\t}\n}\n"]}