{"version":3,"file":"base64.js","sourceRoot":"","sources":["../../../../src/core/base64.ts"],"names":[],"mappings":";;;;;;;;;;;IAAA,yCAAoC;IACpC,kCAAgD;IAEhD,SAAM,CAAC,MAAM,EAAE,MAAM,IAAI,gBAAM,EAAE,IAAI,CAAC,CAAC;IACvC,SAAM,CAAC,MAAM,EAAE,MAAM,IAAI,gBAAM,EAAE,IAAI,CAAC,CAAC;IAEvC;;;OAGG;IACU,QAAA,MAAM,GAAsC,aAAG,CAAC,MAAM,CAAC;QACnE,CAAC,CAAC,UAAS,aAAqB;YAC9B,4DAA4D;YAC5D,MAAM,CAAC,kBAAkB,CACxB,KAAK,CAAC,SAAS,CAAC,GAAG;iBACjB,IAAI,CACJ,IAAI,CAAC,aAAa,CAAC,EACnB,UAAC,IAAY,IAAK,OAAA,GAAG,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAxD,CAAwD,CAC1E;iBACA,IAAI,CAAC,EAAE,CAAC,CACV,CAAC;QACH,CAAC;QACF,CAAC,CAAC,UAAS,aAAqB;YAC9B,MAAM,CAAC,IAAI,MAAM,CAAC,aAAa,CAAC,QAAQ,EAAE,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QACxE,CAAC,CAAC;IAEJ;;;OAGG;IACU,QAAA,MAAM,GAAkC,aAAG,CAAC,MAAM,CAAC;QAC/D,CAAC,CAAC,UAAS,aAAqB;YAC9B,4DAA4D;YAC5D,MAAM,CAAC,IAAI,CACV,kBAAkB,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,iBAAiB,EAAE,UAAC,KAAK,EAAE,IAAY;gBAChF,OAAA,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC;YAAxC,CAAwC,CACxC,CACD,CAAC;QACH,CAAC;QACF,CAAC,CAAC,UAAS,SAAiB;YAC1B,MAAM,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,QAAQ,EAAE,EAAE,MAAM,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACpE,CAAC,CAAC","sourcesContent":["import global from '../shim/global';\nimport has, { add as hasAdd } from '../has/has';\n\nhasAdd('btoa', 'btoa' in global, true);\nhasAdd('atob', 'atob' in global, true);\n\n/**\n * Take a string encoded in base64 and decode it\n * @param encodedString The base64 encoded string\n */\nexport const decode: (encodedString: string) => string = has('atob')\n\t? function(encodedString: string) {\n\t\t\t/* this allows for utf8 characters to be decoded properly */\n\t\t\treturn decodeURIComponent(\n\t\t\t\tArray.prototype.map\n\t\t\t\t\t.call(\n\t\t\t\t\t\tatob(encodedString),\n\t\t\t\t\t\t(char: string) => '%' + ('00' + char.charCodeAt(0).toString(16)).slice(-2)\n\t\t\t\t\t)\n\t\t\t\t\t.join('')\n\t\t\t);\n\t\t}\n\t: function(encodedString: string): string {\n\t\t\treturn new Buffer(encodedString.toString(), 'base64').toString('utf8');\n\t\t};\n\n/**\n * Take a string and encode it to base64\n * @param rawString The string to encode\n */\nexport const encode: (rawString: string) => string = has('btoa')\n\t? function(decodedString: string) {\n\t\t\t/* this allows for utf8 characters to be encoded properly */\n\t\t\treturn btoa(\n\t\t\t\tencodeURIComponent(decodedString).replace(/%([0-9A-F]{2})/g, (match, code: string) =>\n\t\t\t\t\tString.fromCharCode(Number('0x' + code))\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t: function(rawString: string): string {\n\t\t\treturn new Buffer(rawString.toString(), 'utf8').toString('base64');\n\t\t};\n"]}