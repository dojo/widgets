{"version":3,"file":"text.js","sourceRoot":"","sources":["../../../../src/core/text.ts"],"names":[],"mappings":"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","sourcesContent":["import Promise from '../shim/Promise';\nimport has from './has';\nimport request from './request';\nimport { NodeRequire, AmdRequire, AmdConfig } from './interfaces';\nimport { Require, isAmdRequire } from './load';\n\ndeclare const require: Require;\n\n/*\n * Strips <?xml ...?> declarations so that external SVG and XML\n * documents can be added to a document without worry. Also, if the string\n * is an HTML document, only the part inside the body tag is returned.\n */\nfunction strip(text: string): string {\n\tif (!text) {\n\t\treturn '';\n\t}\n\n\ttext = text.replace(/^\\s*<\\?xml(\\s)+version=[\\'\\\"](\\d)*.(\\d)*[\\'\\\"](\\s)*\\?>/im, '');\n\tlet matches = text.match(/<body[^>]*>\\s*([\\s\\S]+)\\s*<\\/body>/im);\n\ttext = matches ? matches[1] : text;\n\n\treturn text;\n}\n\n/*\n * Host-specific method to retrieve text\n */\nlet getText: (url: string, callback: (value: string | null) => void) => void;\n\nif (has('host-browser')) {\n\tgetText = function(url: string, callback: (value: string | null) => void): void {\n\t\trequest(url).then((response) => {\n\t\t\tresponse.text().then((data) => {\n\t\t\t\tcallback(data);\n\t\t\t});\n\t\t});\n\t};\n} else if (has('host-node')) {\n\tlet fs = isAmdRequire(require) && require.nodeRequire ? require.nodeRequire('fs') : (<NodeRequire>require)('fs');\n\tgetText = function(url: string, callback: (value: string) => void): void {\n\t\tfs.readFile(url, { encoding: 'utf8' }, function(error: Error, data: string): void {\n\t\t\tif (error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tcallback(data);\n\t\t});\n\t};\n} else {\n\tgetText = function(): void {\n\t\tthrow new Error('dojo/text not supported on this platform');\n\t};\n}\n\n/*\n * Cache of previously-loaded text resources\n */\nlet textCache: { [key: string]: any } = {};\n\n/*\n * Cache of pending text resources\n */\nlet pending: { [key: string]: any } = {};\n\nexport function get(url: string): Promise<string | null> {\n\tlet promise = new Promise<string | null>(function(resolve, reject) {\n\t\tgetText(url, function(text) {\n\t\t\tresolve(text);\n\t\t});\n\t});\n\n\treturn promise;\n}\n\nexport function normalize(id: string, toAbsMid: (moduleId: string) => string): string {\n\tlet parts = id.split('!');\n\tlet url = parts[0];\n\n\treturn (/^\\./.test(url) ? toAbsMid(url) : url) + (parts[1] ? '!' + parts[1] : '');\n}\n\nexport function load(id: string, require: AmdRequire, load: (value?: any) => void, config?: AmdConfig): void {\n\tlet parts = id.split('!');\n\tlet stripFlag = parts.length > 1;\n\tlet mid = parts[0];\n\tlet url = require.toUrl(mid);\n\tlet text: string | undefined;\n\n\tfunction finish(text: string): void {\n\t\tload(stripFlag ? strip(text) : text);\n\t}\n\n\tif (mid in textCache) {\n\t\ttext = textCache[mid];\n\t} else if (url in textCache) {\n\t\ttext = textCache[url];\n\t}\n\n\tif (!text) {\n\t\tif (pending[url]) {\n\t\t\tpending[url].push(finish);\n\t\t} else {\n\t\t\tlet pendingList = (pending[url] = [finish]);\n\t\t\tgetText(url, function(value) {\n\t\t\t\ttextCache[mid] = textCache[url] = value;\n\t\t\t\tfor (let i = 0; i < pendingList.length; ) {\n\t\t\t\t\tpendingList[i++](value || '');\n\t\t\t\t}\n\t\t\t\tdelete pending[url];\n\t\t\t});\n\t\t}\n\t} else {\n\t\tfinish(text);\n\t}\n}\n"]}