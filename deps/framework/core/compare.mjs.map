{"version":3,"file":"compare.mjs","sourceRoot":"","sources":["../../../../src/core/compare.ts"],"names":[],"mappings":"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","sourcesContent":["import { assign } from '../shim/object';\nimport { keys } from '../shim/object';\nimport Set from '../shim/Set';\n\n/* Assigning to local variables to improve minification and readability */\n\nconst objectCreate = Object.create;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst defineProperty = Object.defineProperty;\nconst isArray = Array.isArray;\nconst isFrozen = Object.isFrozen;\nconst isSealed = Object.isSealed;\n\nexport type IgnorePropertyFunction = (name: string, a: any, b: any) => boolean;\n\nexport interface DiffOptions {\n\t/**\n\t * Allow functions to be values.  Values will be considered equal if the `typeof` both values are `function`.\n\t * When adding or updating the property, the value of the property of `a` will be used in the record, which\n\t * will be a reference to the function.\n\t */\n\tallowFunctionValues?: boolean;\n\n\t/**\n\t * An array of strings or regular expressions which flag certain properties to be ignored.  Alternatively\n\t * a function, which returns `true` to have the property ignored or `false` to diff the property.\n\t */\n\tignoreProperties?: (string | RegExp)[] | IgnorePropertyFunction;\n\n\t/**\n\t * An array of strings or regular expressions which flag certain values to be ignored.  For flagged properties,\n\t * if the property is present in both `a` and `b` the value will be ignored.  If adding the property,\n\t * whatever the value of the property of `a` will be used, which could be a reference.\n\t */\n\tignorePropertyValues?: (string | RegExp)[] | IgnorePropertyFunction;\n}\n\n/**\n * Interface for a generic constructor function\n */\nexport interface Constructor {\n\tnew (...args: any[]): object;\n\tprototype: object;\n}\n\n/**\n * A partial property descriptor that provides the property descriptor flags supported by the\n * complex property construction of `patch()`\n *\n * All properties are value properties, with the value being supplied by the `ConstructRecord`\n */\nexport interface ConstructDescriptor {\n\t/**\n\t * Is the property configurable?\n\t */\n\tconfigurable?: boolean;\n\n\t/**\n\t * Is the property enumerable?\n\t */\n\tenumerable?: boolean;\n\n\t/**\n\t * Is the property configurable?\n\t */\n\twritable?: boolean;\n}\n\n/**\n * A record that describes a constructor function and arguments necessary to create an instance of\n * an object\n */\nexport interface AnonymousConstructRecord {\n\t/**\n\t * Any arguments to pass to the constructor function\n\t */\n\targs?: any[];\n\n\t/**\n\t * The constructor function to use to create the instance\n\t */\n\tCtor: Constructor;\n\n\t/**\n\t * The partial descriptor that is used to set the value of the instance\n\t */\n\tdescriptor?: ConstructDescriptor;\n\n\t/**\n\t * Any patches to properties that need to occur on the instance\n\t */\n\tpropertyRecords?: (ConstructRecord | PatchRecord)[];\n}\n\nexport interface ConstructRecord extends AnonymousConstructRecord {\n\t/**\n\t * The name of the property on the Object\n\t */\n\tname: string;\n}\n\n/**\n * A record that describes the mutations necessary to a property of an object to make that property look\n * like another\n */\nexport type PatchRecord =\n\t| {\n\t\t\t/**\n\t\t\t * The name of the property on the Object\n\t\t\t */\n\t\t\tname: string;\n\n\t\t\t/**\n\t\t\t * The type of the patch\n\t\t\t */\n\t\t\ttype: 'delete';\n\t\t}\n\t| {\n\t\t\t/**\n\t\t\t * A property descriptor that describes the property in `name`\n\t\t\t */\n\t\t\tdescriptor: PropertyDescriptor;\n\n\t\t\t/**\n\t\t\t * The name of the property on the Object\n\t\t\t */\n\t\t\tname: string;\n\n\t\t\t/**\n\t\t\t * The type of the patch\n\t\t\t */\n\t\t\ttype: 'add' | 'update';\n\n\t\t\t/**\n\t\t\t * Additional patch records which describe the value of the property\n\t\t\t */\n\t\t\tvalueRecords?: (ConstructRecord | PatchRecord | SpliceRecord)[];\n\t\t};\n\n/**\n * The different types of patch records supported\n */\nexport type PatchTypes = 'add' | 'update' | 'delete';\n\n/**\n * A record that describes a splice operation to perform on an array to make the array look like another array\n */\nexport interface SpliceRecord {\n\t/**\n\t * Any items that are being added to the array\n\t */\n\tadd?: any[];\n\n\t/**\n\t * The number of items in the array to delete\n\t */\n\tdeleteCount: number;\n\n\t/**\n\t * The type, set to `splice`\n\t */\n\ttype: 'splice';\n\n\t/**\n\t * The index of where to start the splice\n\t */\n\tstart: number;\n}\n\n/**\n * A record that describes how to instantiate a new object via a constructor function\n * @param Ctor The constructor function\n * @param args Any arguments to be passed to the constructor function\n */\n/* tslint:disable:variable-name */\nexport function createConstructRecord(\n\tCtor: Constructor,\n\targs?: any[],\n\tdescriptor?: ConstructDescriptor\n): AnonymousConstructRecord {\n\tconst record: AnonymousConstructRecord = assign(objectCreate(null), { Ctor });\n\tif (args) {\n\t\trecord.args = args;\n\t}\n\tif (descriptor) {\n\t\trecord.descriptor = descriptor;\n\t}\n\treturn record;\n}\n/* tslint:enable:variable-name */\n\n/**\n * An internal function that returns a new patch record\n *\n * @param type The type of patch record\n * @param name The property name the record refers to\n * @param descriptor The property descriptor to be installed on the object\n * @param valueRecords Any subsequenet patch recrds to be applied to the value of the descriptor\n */\nfunction createPatchRecord(\n\ttype: PatchTypes,\n\tname: string,\n\tdescriptor?: PropertyDescriptor,\n\tvalueRecords?: (ConstructRecord | PatchRecord | SpliceRecord)[]\n): PatchRecord {\n\tconst patchRecord = assign(objectCreate(null), {\n\t\ttype,\n\t\tname\n\t});\n\n\tif (descriptor) {\n\t\tpatchRecord.descriptor = descriptor;\n\t}\n\tif (valueRecords) {\n\t\tpatchRecord.valueRecords = valueRecords;\n\t}\n\n\treturn patchRecord as PatchRecord;\n}\n\n/**\n * An internal function that returns a new splice record\n *\n * @param start Where in the array to start the splice\n * @param deleteCount The number of elements to delete from the array\n * @param add Elements to be added to the target\n */\nfunction createSpliceRecord(start: number, deleteCount: number, add?: any[]): SpliceRecord {\n\tconst spliceRecord: SpliceRecord = assign(objectCreate(null), {\n\t\ttype: 'splice',\n\t\tstart,\n\t\tdeleteCount\n\t});\n\n\tif (add && add.length) {\n\t\tspliceRecord.add = add;\n\t}\n\n\treturn spliceRecord;\n}\n\n/**\n * A function that produces a value property descriptor, which assumes that properties are enumerable, writable and configurable\n * unless specified\n *\n * @param value The value for the descriptor\n * @param writable Defaults to `true` if not specified\n * @param enumerable Defaults to `true` if not specified\n * @param configurable Defaults to `true` if not specified\n */\nfunction createValuePropertyDescriptor(\n\tvalue: any,\n\twritable: boolean = true,\n\tenumerable: boolean = true,\n\tconfigurable: boolean = true\n): PropertyDescriptor {\n\treturn assign(objectCreate(null), {\n\t\tvalue,\n\t\twritable,\n\t\tenumerable,\n\t\tconfigurable\n\t});\n}\n\n/**\n * A function that returns a constructor record or `undefined` when diffing a value\n */\nexport type CustomDiffFunction<T> = (\n\tvalue: T,\n\tnameOrIndex: string | number,\n\tparent: object\n) => AnonymousConstructRecord | void;\n\n/**\n * A class which is used when making a custom comparison of a non-plain object or array\n */\nexport class CustomDiff<T> {\n\tprivate _differ: CustomDiffFunction<T>;\n\n\tconstructor(diff: CustomDiffFunction<T>) {\n\t\tthis._differ = diff;\n\t}\n\n\t/**\n\t * Get the difference of the `value`\n\t * @param value The value to diff\n\t * @param nameOrIndex A `string` if comparing a property or a `number` if comparing an array element\n\t * @param parent The outer parent that this value is part of\n\t */\n\tdiff(value: T, nameOrIndex: string | number, parent: object): ConstructRecord | void {\n\t\tconst record = this._differ(value, nameOrIndex, parent);\n\t\tif (record && typeof nameOrIndex === 'string') {\n\t\t\treturn assign(record, { name: nameOrIndex });\n\t\t}\n\t}\n}\n\n/**\n * Internal function that detects the differences between an array and another value and returns a set of splice records that\n * describe the differences\n *\n * @param a The first array to compare to\n * @param b The second value to compare to\n * @param options An options bag that allows configuration of the behaviour of `diffArray()`\n */\nfunction diffArray(a: any[], b: any, options: DiffOptions): SpliceRecord[] {\n\t/* This function takes an overly simplistic approach to calculating splice records.  There are many situations where\n\t * in complicated array mutations, the splice records can be more optimised.\n\t *\n\t * TODO: Raise an issue for this when it is finally merged and put into core\n\t */\n\n\tconst { allowFunctionValues = false } = options;\n\n\tconst arrayA = a;\n\tconst lengthA = arrayA.length;\n\tconst arrayB = isArray(b) ? b : [];\n\tconst lengthB = arrayB.length;\n\tconst patchRecords: SpliceRecord[] = [];\n\n\tif (!lengthA && lengthB) {\n\t\t/* empty array */\n\t\tpatchRecords.push(createSpliceRecord(0, lengthB));\n\t\treturn patchRecords;\n\t}\n\n\tlet add: any[] = [];\n\tlet start = 0;\n\tlet deleteCount = 0;\n\tlet last = -1;\n\n\tfunction flushSpliceRecord() {\n\t\tif (deleteCount || add.length) {\n\t\t\tpatchRecords.push(\n\t\t\t\tcreateSpliceRecord(start, start + deleteCount > lengthB ? lengthB - start : deleteCount, add)\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction addDifference(index: number, adding: boolean, value?: any) {\n\t\tif (index > last + 1) {\n\t\t\t/* flush the splice */\n\t\t\tflushSpliceRecord();\n\t\t\tstart = index;\n\t\t\tdeleteCount = 0;\n\t\t\tif (add.length) {\n\t\t\t\tadd = [];\n\t\t\t}\n\t\t}\n\n\t\tif (adding) {\n\t\t\tadd.push(value);\n\t\t}\n\t\tdeleteCount++;\n\t\tlast = index;\n\t}\n\n\tarrayA.forEach((valueA, index) => {\n\t\tconst valueB = arrayB[index];\n\n\t\tif (\n\t\t\tindex in arrayB &&\n\t\t\t(valueA === valueB || (allowFunctionValues && typeof valueA === 'function' && typeof valueB === 'function'))\n\t\t) {\n\t\t\treturn; /* not different */\n\t\t}\n\n\t\tconst isValueAArray = isArray(valueA);\n\t\tconst isValueAPlainObject = isPlainObject(valueA);\n\n\t\tif (isValueAArray || isValueAPlainObject) {\n\t\t\tconst value = isValueAArray\n\t\t\t\t? isArray(valueB) ? valueB : []\n\t\t\t\t: isPlainObject(valueB) ? valueB : Object.create(null);\n\t\t\tconst valueRecords = diff(valueA, value, options);\n\t\t\tif (valueRecords.length) {\n\t\t\t\t/* only add if there are changes */\n\t\t\t\taddDifference(index, true, diff(valueA, value, options));\n\t\t\t}\n\t\t} else if (isPrimitive(valueA)) {\n\t\t\taddDifference(index, true, valueA);\n\t\t} else if (allowFunctionValues && typeof valueA === 'function') {\n\t\t\taddDifference(index, true, valueA);\n\t\t} else {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Value of array element \"${index}\" from first argument is not a primative, plain Object, or Array.`\n\t\t\t);\n\t\t}\n\t});\n\n\tif (lengthB > lengthA) {\n\t\tfor (let index = lengthA; index < lengthB; index++) {\n\t\t\taddDifference(index, false);\n\t\t}\n\t}\n\n\t/* flush any deletes */\n\tflushSpliceRecord();\n\n\treturn patchRecords;\n}\n\n/**\n * Internal function that detects the differences between plain objects and returns a set of patch records that\n * describe the differences\n *\n * @param a The first plain object to compare to\n * @param b The second plain bject to compare to\n * @param options An options bag that allows configuration of the behaviour of `diffPlainObject()`\n */\nfunction diffPlainObject(a: any, b: any, options: DiffOptions): (ConstructRecord | PatchRecord)[] {\n\tconst { allowFunctionValues = false, ignorePropertyValues = [] } = options;\n\tconst patchRecords: (ConstructRecord | PatchRecord)[] = [];\n\tconst { comparableA, comparableB } = getComparableObjects(a, b, options);\n\n\t/* look for keys in a that are different from b */\n\tkeys(comparableA).reduce((patchRecords, name) => {\n\t\tconst valueA = a[name];\n\t\tconst valueB = b[name];\n\t\tconst bHasOwnProperty = hasOwnProperty.call(comparableB, name);\n\n\t\tif (\n\t\t\tbHasOwnProperty &&\n\t\t\t(valueA === valueB || (allowFunctionValues && typeof valueA === 'function' && typeof valueB === 'function'))\n\t\t) {\n\t\t\t/* not different */\n\t\t\t/* when `allowFunctionValues` is true, functions are simply considered to be equal by `typeof` */\n\t\t\treturn patchRecords;\n\t\t}\n\n\t\tconst type = bHasOwnProperty ? 'update' : 'add';\n\n\t\tconst isValueAArray = isArray(valueA);\n\t\tconst isValueAPlainObject = isPlainObject(valueA);\n\n\t\tif (isValueAArray || isValueAPlainObject) {\n\t\t\t/* non-primitive values we can diff */\n\t\t\t/* this is a bit complicated, but essentially if valueA and valueB are both arrays or plain objects, then\n\t\t\t* we can diff those two values, if not, then we need to use an empty array or an empty object and diff\n\t\t\t* the valueA with that */\n\t\t\tconst value =\n\t\t\t\t(isValueAArray && isArray(valueB)) || (isValueAPlainObject && isPlainObject(valueB))\n\t\t\t\t\t? valueB\n\t\t\t\t\t: isValueAArray ? [] : objectCreate(null);\n\t\t\tconst valueRecords = diff(valueA, value, options);\n\t\t\tif (valueRecords.length) {\n\t\t\t\t/* only add if there are changes */\n\t\t\t\tpatchRecords.push(\n\t\t\t\t\tcreatePatchRecord(type, name, createValuePropertyDescriptor(value), diff(valueA, value, options))\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (isCustomDiff(valueA) && !isCustomDiff(valueB)) {\n\t\t\t/* complex diff left hand */\n\t\t\tconst result = valueA.diff(valueB, name, b);\n\t\t\tif (result) {\n\t\t\t\tpatchRecords.push(result);\n\t\t\t}\n\t\t} else if (isCustomDiff(valueB)) {\n\t\t\t/* complex diff right hand */\n\t\t\tconst result = valueB.diff(valueA, name, a);\n\t\t\tif (result) {\n\t\t\t\tpatchRecords.push(result);\n\t\t\t}\n\t\t} else if (\n\t\t\tisPrimitive(valueA) ||\n\t\t\t(allowFunctionValues && typeof valueA === 'function') ||\n\t\t\tisIgnoredPropertyValue(name, a, b, ignorePropertyValues)\n\t\t) {\n\t\t\t/* primitive values, functions values if allowed, or ignored property values can just be copied */\n\t\t\tpatchRecords.push(createPatchRecord(type, name, createValuePropertyDescriptor(valueA)));\n\t\t} else {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Value of property named \"${name}\" from first argument is not a primative, plain Object, or Array.`\n\t\t\t);\n\t\t}\n\t\treturn patchRecords;\n\t}, patchRecords);\n\n\t/* look for keys in b that are not in a */\n\tkeys(comparableB).reduce((patchRecords, name) => {\n\t\tif (!hasOwnProperty.call(comparableA, name)) {\n\t\t\tpatchRecords.push(createPatchRecord('delete', name));\n\t\t}\n\t\treturn patchRecords;\n\t}, patchRecords);\n\n\treturn patchRecords;\n}\n\n/**\n * Takes two plain objects to be compared, as well as options customizing the behavior of the comparison, and returns\n * two new objects that contain only those properties that should be compared. If a property is ignored\n * it will not be included in either returned object. If a property's value should be ignored it will be excluded\n * if it is present in both objects.\n * @param a The first object to compare\n * @param b The second object to compare\n * @param options An options bag indicating which properties should be ignored or have their values ignored, if any.\n */\nexport function getComparableObjects(a: any, b: any, options: DiffOptions) {\n\tconst { ignoreProperties = [], ignorePropertyValues = [] } = options;\n\tconst ignore = new Set<string>();\n\tconst keep = new Set<string>();\n\n\tconst isIgnoredProperty = Array.isArray(ignoreProperties)\n\t\t? (name: string) => {\n\t\t\t\treturn ignoreProperties.some(\n\t\t\t\t\t(value) => (typeof value === 'string' ? name === value : value.test(name))\n\t\t\t\t);\n\t\t\t}\n\t\t: (name: string) => ignoreProperties(name, a, b);\n\n\tconst comparableA = keys(a).reduce(\n\t\t(obj, name) => {\n\t\t\tif (\n\t\t\t\tisIgnoredProperty(name) ||\n\t\t\t\t(hasOwnProperty.call(b, name) && isIgnoredPropertyValue(name, a, b, ignorePropertyValues))\n\t\t\t) {\n\t\t\t\tignore.add(name);\n\t\t\t\treturn obj;\n\t\t\t}\n\n\t\t\tkeep.add(name);\n\t\t\tobj[name] = a[name];\n\t\t\treturn obj;\n\t\t},\n\t\t{} as { [key: string]: any }\n\t);\n\n\tconst comparableB = keys(b).reduce(\n\t\t(obj, name) => {\n\t\t\tif (ignore.has(name) || (!keep.has(name) && isIgnoredProperty(name))) {\n\t\t\t\treturn obj;\n\t\t\t}\n\n\t\t\tobj[name] = b[name];\n\t\t\treturn obj;\n\t\t},\n\t\t{} as { [key: string]: any }\n\t);\n\n\treturn { comparableA, comparableB, ignore };\n}\n\n/**\n * A guard that determines if the value is a `ConstructRecord`\n * @param value The value to check\n */\nfunction isConstructRecord(value: any): value is ConstructRecord {\n\treturn Boolean(value && typeof value === 'object' && value !== null && value.Ctor && value.name);\n}\n\nfunction isIgnoredPropertyValue(\n\tname: string,\n\ta: any,\n\tb: any,\n\tignoredPropertyValues: (string | RegExp)[] | IgnorePropertyFunction\n) {\n\treturn Array.isArray(ignoredPropertyValues)\n\t\t? ignoredPropertyValues.some((value) => {\n\t\t\t\treturn typeof value === 'string' ? name === value : value.test(name);\n\t\t\t})\n\t\t: ignoredPropertyValues(name, a, b);\n}\n\n/**\n * A guard that determines if the value is a `PatchRecord`\n *\n * @param value The value to check\n */\nfunction isPatchRecord(value: any): value is PatchRecord {\n\treturn Boolean(value && value.type && value.name);\n}\n\n/**\n * A guard that determines if the value is an array of `PatchRecord`s\n *\n * @param value The value to check\n */\nfunction isPatchRecordArray(value: any): value is PatchRecord[] {\n\treturn Boolean(isArray(value) && value.length && isPatchRecord(value[0]));\n}\n\n/**\n * A guard that determines if the value is a plain object.  A plain object is an object that has\n * either no constructor (e.g. `Object.create(null)`) or has Object as its constructor.\n *\n * @param value The value to check\n */\nfunction isPlainObject(value: any): value is Object {\n\treturn Boolean(\n\t\tvalue && typeof value === 'object' && (value.constructor === Object || value.constructor === undefined)\n\t);\n}\n\n/**\n * A guard that determines if the value is a primitive (including `null`), as these values are\n * fine to just copy.\n *\n * @param value The value to check\n */\nfunction isPrimitive(value: any): value is string | number | boolean | undefined | null {\n\tconst typeofValue = typeof value;\n\treturn (\n\t\tvalue === null ||\n\t\ttypeofValue === 'undefined' ||\n\t\ttypeofValue === 'string' ||\n\t\ttypeofValue === 'number' ||\n\t\ttypeofValue === 'boolean'\n\t);\n}\n\n/**\n * A guard that determines if the value is a `CustomDiff`\n * @param value The value to check\n */\nfunction isCustomDiff<T>(value: any): value is CustomDiff<T> {\n\treturn typeof value === 'object' && value instanceof CustomDiff;\n}\n\n/**\n * A guard that determines if the value is a `SpliceRecord`\n *\n * @param value The value to check\n */\nfunction isSpliceRecord(value: any): value is SpliceRecord {\n\treturn value && value.type === 'splice' && 'start' in value && 'deleteCount' in value;\n}\n\n/**\n * A guard that determines if the value is an array of `SpliceRecord`s\n *\n * @param value The value to check\n */\nfunction isSpliceRecordArray(value: any): value is SpliceRecord[] {\n\treturn Boolean(isArray(value) && value.length && isSpliceRecord(value[0]));\n}\n\n/**\n * An internal function that patches a target with a `SpliceRecord`\n */\nfunction patchSplice(target: any[], { add, deleteCount, start }: SpliceRecord): any {\n\tif (add && add.length) {\n\t\tconst deletedItems = deleteCount ? target.slice(start, start + deleteCount) : [];\n\t\tadd = add.map((value, index) => resolveTargetValue(value, deletedItems[index]));\n\t\ttarget.splice(start, deleteCount, ...add);\n\t} else {\n\t\ttarget.splice(start, deleteCount);\n\t}\n\treturn target;\n}\n\n/**\n * An internal function that patches a target with a `PatchRecord`\n */\nfunction patchPatch(target: any, record: PatchRecord): any {\n\tconst { name } = record;\n\tif (record.type === 'delete') {\n\t\tdelete target[name];\n\t\treturn target;\n\t}\n\tconst { descriptor, valueRecords } = record;\n\tif (valueRecords && valueRecords.length) {\n\t\tdescriptor.value = patch(descriptor.value, valueRecords);\n\t}\n\tdefineProperty(target, name, descriptor);\n\treturn target;\n}\n\nconst defaultConstructDescriptor = {\n\tconfigurable: true,\n\tenumerable: true,\n\twritable: true\n};\n\nfunction patchConstruct(target: any, record: ConstructRecord): any {\n\tconst { args, descriptor = defaultConstructDescriptor, Ctor, name, propertyRecords } = record;\n\tconst value = new Ctor(...(args || []));\n\tif (propertyRecords) {\n\t\tpropertyRecords.forEach(\n\t\t\t(record) => (isConstructRecord(record) ? patchConstruct(value, record) : patchPatch(value, record))\n\t\t);\n\t}\n\tdefineProperty(target, name, assign({ value }, descriptor));\n\treturn target;\n}\n\n/**\n * An internal function that takes a value from array being patched and the target value from the same\n * index and determines the value that should actually be patched into the target array\n */\nfunction resolveTargetValue(patchValue: any, targetValue: any): any {\n\tconst patchIsSpliceRecordArray = isSpliceRecordArray(patchValue);\n\treturn patchIsSpliceRecordArray || isPatchRecordArray(patchValue)\n\t\t? patch(\n\t\t\t\tpatchIsSpliceRecordArray\n\t\t\t\t\t? isArray(targetValue) ? targetValue : []\n\t\t\t\t\t: isPlainObject(targetValue) ? targetValue : objectCreate(null),\n\t\t\t\tpatchValue\n\t\t\t)\n\t\t: patchValue;\n}\n\n/**\n * Compares two plain objects or arrays and return a set of records which describe the differences between the two\n *\n * The records describe what would need to be applied to the second argument to make it look like the first argument\n *\n * @param a The plain object or array to compare with\n * @param b The plain object or array to compare to\n * @param options An options bag that allows configuration of the behaviour of `diff()`\n */\nexport function diff(a: any, b: any, options: DiffOptions = {}): (ConstructRecord | PatchRecord | SpliceRecord)[] {\n\tif (typeof a !== 'object' || typeof b !== 'object') {\n\t\tthrow new TypeError('Arguments are not of type object.');\n\t}\n\n\tif (isArray(a)) {\n\t\treturn diffArray(a, b, options);\n\t}\n\n\tif (isArray(b)) {\n\t\tb = objectCreate(null);\n\t}\n\n\tif (!isPlainObject(a) || !isPlainObject(b)) {\n\t\tthrow new TypeError('Arguments are not plain Objects or Arrays.');\n\t}\n\n\treturn diffPlainObject(a, b, options);\n}\n\n/**\n * Apply a set of patch records to a target.\n *\n * @param target The plain object or array that the patch records should be applied to\n * @param records A set of patch records to be applied to the target\n */\nexport function patch(target: any, records: (ConstructRecord | PatchRecord | SpliceRecord)[]): any {\n\tif (!isArray(target) && !isPlainObject(target)) {\n\t\tthrow new TypeError('A target for a patch must be either an array or a plain object.');\n\t}\n\tif (isFrozen(target) || isSealed(target)) {\n\t\tthrow new TypeError('Cannot patch sealed or frozen objects.');\n\t}\n\n\trecords.forEach((record) => {\n\t\ttarget = isSpliceRecord(record)\n\t\t\t? patchSplice(isArray(target) ? target : [], record) /* patch arrays */\n\t\t\t: isConstructRecord(record)\n\t\t\t\t? patchConstruct(target, record) /* patch complex object */\n\t\t\t\t: patchPatch(isPlainObject(target) ? target : {}, record); /* patch plain object */\n\t});\n\treturn target;\n}\n"]}