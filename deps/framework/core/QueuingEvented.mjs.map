{"version":3,"file":"QueuingEvented.mjs","sourceRoot":"","sources":["../../../../src/core/QueuingEvented.ts"],"names":[],"mappings":"AACA,OAAO,GAAG,MAAM,aAAa,CAAC;AAC9B,OAAO,OAAO,EAAE,EAAoB,WAAW,EAA0B,MAAM,WAAW,CAAC;AAE3F;;;;;;GAMG;AACH,oBAIE,SAAQ,OAAgB;IAJ1B;;QAKS,WAAM,GAAwC,IAAI,GAAG,EAAE,CAAC;QAEzD,cAAS,GAAG,CAAC,CAAC;IAkDtB,CAAC;IA9CA,IAAI,CAAC,KAAU;QACd,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAElB,IAAI,QAAQ,GAAG,KAAK,CAAC;QAErB,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE;YAC1C,kHAAkH;YAClH,EAAE,CAAC,CAAC,WAAW,CAAC,IAAW,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC1C,QAAQ,GAAG,IAAI,CAAC;YACjB,CAAC;QACF,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;YACf,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YAExC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACZ,KAAK,GAAG,EAAE,CAAC;gBACX,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YACpC,CAAC;YAED,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAElB,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;gBACxB,OAAO,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;oBACtC,KAAK,CAAC,KAAK,EAAE,CAAC;gBACf,CAAC;YACF,CAAC;QACF,CAAC;IACF,CAAC;IAID,EAAE,CAAC,IAAS,EAAE,QAA0C;QACvD,IAAI,MAAM,GAAG,KAAK,CAAC,EAAE,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QAEtC,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,YAAY,EAAE,EAAE;YAClD,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,UAAU,EAAE,EAAE;gBAC1C,EAAE,CAAC,CAAC,WAAW,CAAC,YAAmB,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC;oBAClD,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;oBAC5C,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;gBAChC,CAAC;YACF,CAAC,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,MAAM,CAAC;IACf,CAAC;CACD;AAED,eAAe,cAAc,CAAC","sourcesContent":["import { Handle, EventObject, EventType } from './interfaces';\nimport Map from '../shim/Map';\nimport Evented, { CustomEventTypes, isGlobMatch, EventedCallbackOrArray } from './Evented';\n\n/**\n * An implementation of the Evented class that queues up events when no listeners are\n * listening. When a listener is subscribed, the queue will be published to the listener.\n * When the queue is full, the oldest events will be discarded to make room for the newest ones.\n *\n * @property maxEvents  The number of events to queue before old events are discarded. If zero (default), an unlimited number of events is queued.\n */\nclass QueuingEvented<\n\tM extends CustomEventTypes = {},\n\tT = EventType,\n\tO extends EventObject<T> = EventObject<T>\n> extends Evented<M, T, O> {\n\tprivate _queue: Map<string | symbol, EventObject[]> = new Map();\n\n\tpublic maxEvents = 0;\n\n\temit<K extends keyof M>(event: M[K]): void;\n\temit(event: O): void;\n\temit(event: any): void {\n\t\tsuper.emit(event);\n\n\t\tlet hasMatch = false;\n\n\t\tthis.listenersMap.forEach((method, type) => {\n\t\t\t// Since `type` is generic, the compiler doesn't know what type it is and `isGlobMatch` requires `string | symbol`\n\t\t\tif (isGlobMatch(type as any, event.type)) {\n\t\t\t\thasMatch = true;\n\t\t\t}\n\t\t});\n\n\t\tif (!hasMatch) {\n\t\t\tlet queue = this._queue.get(event.type);\n\n\t\t\tif (!queue) {\n\t\t\t\tqueue = [];\n\t\t\t\tthis._queue.set(event.type, queue);\n\t\t\t}\n\n\t\t\tqueue.push(event);\n\n\t\t\tif (this.maxEvents > 0) {\n\t\t\t\twhile (queue.length > this.maxEvents) {\n\t\t\t\t\tqueue.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ton<K extends keyof M>(type: K, listener: EventedCallbackOrArray<K, M[K]>): Handle;\n\ton(type: T, listener: EventedCallbackOrArray<T, O>): Handle;\n\ton(type: any, listener: EventedCallbackOrArray<any, any>): Handle {\n\t\tlet handle = super.on(type, listener);\n\n\t\tthis.listenersMap.forEach((method, listenerType) => {\n\t\t\tthis._queue.forEach((events, queuedType) => {\n\t\t\t\tif (isGlobMatch(listenerType as any, queuedType)) {\n\t\t\t\t\tevents.forEach((event) => this.emit(event));\n\t\t\t\t\tthis._queue.delete(queuedType);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn handle;\n\t}\n}\n\nexport default QueuingEvented;\n"]}